<?xml version="1.0" encoding="ISO-8859-1"?>
<!--  The tags attribute is a free test attribute which meaning is defined by the uHAL user -->
<node id="top">
  <node id="GEM_AMC">

    <!--TTC module -->
    <node id="TTC"  address="0x00300000"
          description="TTC control and monitoring. It takes care of locking to the TTC clock coming from the
                       backplane as well as decoding TTC commands and forwarding that to all other modules in
                       the design. It also provides several control and monitoring registers (resets, command
                       decoding configuration, clock and data status, bc0 status, command counters and a small spy buffer)"
          fw_is_module="true"
          fw_module_file="../common/hdl/ttc/ttc.vhd"
          fw_user_clock_signal="ttc_clks_i.clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="5"
          fw_reg_addr_lsb="0">
      <node id="CTRL" address="0x0"
            description="TTC control">
        <node id="MODULE_RESET" address="0x0" permission="w"
              description="TTC module reset"
              fw_write_pulse_signal="ttc_ctrl.reset_local"/>
        <node id="MMCM_RESET" address="0x1" permission="w"
              description="TTC MMCM reset"
              fw_write_pulse_signal="ttc_ctrl.mmcm_reset"/>
        <node id="CNT_RESET" address="0x2" permission="w"
              description="TTC counter reset"
              fw_write_pulse_signal="ttc_ctrl.cnt_reset"
              sw_ctrl_configure_set="0x1" sw_ctrl_start_set="0x1"/>
        <node id="MMCM_PHASE_SHIFT" address="0x3" permission="w"
              description="TTC MMCM phase shift trigger"
              fw_write_pulse_signal="ttc_ctrl.mmcm_phase_shift"/>
        <node id="L1A_ENABLE" address="0x4" mask="0x00000001" permission="rw"
              description="Enable L1As (L1As are blocked if this is 0)"
              fw_signal="ttc_ctrl.l1a_enable" fw_default="0b1"
              sw_ctrl_configure_set="0x0" sw_ctrl_start_set="0x1" sw_ctrl_stop_set="0x0"/>
        <node id="CALIBRATION_MODE" address="0x4" mask="0x00000002" permission="rw"
              description="Enables calibration mode when set to 1. In calibration mode the incoming L1A commands will actually trigger a calpulse signal to the frontend,
                           followed by an L1A after a fixed delay, which is controlled by the CALPULSE_L1A_DELAY register below."
              fw_signal="ttc_ctrl.calib_mode" fw_default="0b0"
              sw_ctrl_configure_set="0x0" sw_ctrl_start_set="0x0" sw_ctrl_stop_set="0x0"/>
        <node id="CALPULSE_L1A_DELAY" address="0x4" mask="0xfff00000" permission="rw"
              description="When calibration mode is enabled, this register controls the delay between the calpulse and the L1A to the frontend
                           e.g. a setting of 1 will have the calpulse and L1A sent in consecutive clock cycles, a setting of 2 will have one empty BX between the calpulse and L1a, etc..
                           Note that 0 is not a valid setting and will result in no L1As being sent to frontend.
                           Also note that if another L1A comes in while this delay is still being processed, it will restart the delay and result in the previous L1A to the frontend being cancelled,
                           so don't set this delay longer than the delay between consecutive L1As in AMC13."
              fw_signal="ttc_ctrl.calib_l1a_delay" fw_default="0x064"/>
      </node>
      <node id="CONFIG" address="0x5"
            description="TTC configuration -- used for setup TTC command decoding">
        <node id="CMD_BC0" address="0x0" mask="0x000000ff" permission="rw"
              description="BC0 command code"
              fw_signal="ttc_conf.cmd_bc0" fw_default="0x01"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_EC0" address="0x0" mask="0x0000ff00" permission="rw"
              description="EC0 command code"
              fw_signal="ttc_conf.cmd_ec0" fw_default="0x02"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_RESYNC" address="0x0" mask="0x00ff0000" permission="rw"
              description="Resync command code"
              fw_signal="ttc_conf.cmd_resync" fw_default="0x04"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_OC0" address="0x0" mask="0xff000000" permission="rw"
              description="OC0 command code"
              fw_signal="ttc_conf.cmd_oc0" fw_default="0x08"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_HARD_RESET" address="0x1" mask="0x000000ff" permission="rw"
              description="Hard-reset command code"
              fw_signal="ttc_conf.cmd_hard_reset" fw_default="0x10"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_CALPULSE" address="0x1" mask="0x0000ff00" permission="rw"
              description="Calibration pulse command code"
              fw_signal="ttc_conf.cmd_calpulse" fw_default="0x14"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_START" address="0x1" mask="0x00ff0000" permission="rw"
              description="START command code"
              fw_signal="ttc_conf.cmd_start" fw_default="0x18"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_STOP" address="0x1" mask="0xff000000" permission="rw"
              description="STOP command code"
              fw_signal="ttc_conf.cmd_stop" fw_default="0x1c"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_TEST_SYNC" address="0x2" mask="0x000000ff" permission="rw"
              description="Test-sync command code"
              fw_signal="ttc_conf.cmd_test_sync" fw_default="0x20"
              sw_ctrl_configure_confdb_check_set="true"/>
      </node>
      <node id="STATUS" address="0x8"
            description="TTC status">
        <node id="MMCM_LOCKED" address="0x0" mask="0x00000001" permission="r"
              description="MMCM locked flag"
              fw_signal="ttc_status.mmcm_locked"
              sw_monitor_error_value="0"/>
        <node id="MMCM_UNLOCK_CNT" address="0x0" mask="0xffff0000" permission="r" description="MMCM unlock counter"
              fw_signal="mmcm_unlock_cnt"
              sw_monitor_warn_min_threshold="1"/>
        <node id="TTC_SINGLE_ERROR_CNT" address="0x1" mask="0x0000ffff" permission="r"
              description="TTC stream single bit error count"
              fw_signal="ttc_status.single_err"
              sw_monitor_warn_min_threshold="1"/>
        <node id="TTC_DOUBLE_ERROR_CNT" address="0x1" mask="0xffff0000" permission="r"
              description="TTC stream double bit error count"
              fw_signal="ttc_status.double_err"
              sw_monitor_error_min_threshold="1"/>
        <node id="BC0" address="0x2"
              description="TTC status">
          <node id="LOCKED" address="0x0" mask="0x00000001" permission="r"
                description="BC0 locked flag"
                fw_signal="ttc_status.bc0_status.locked"
                sw_monitor_error_value="0"/>
          <node id="UNLOCK_CNT" address="0x1" mask="0x0000ffff" permission="r"
                description="BC0 unlock count"
                fw_signal="ttc_status.bc0_status.unlocked_cnt"
                sw_monitor_error_min_threshold="1"/>
          <node id="OVERFLOW_CNT" address="0x2" mask="0x0000ffff" permission="r"
                description="BX counter overflow count (late or no BC0 received)"
                fw_signal="ttc_status.bc0_status.ovf_cnt"
                sw_monitor_error_min_threshold="1"/>
          <node id="UNDERFLOW_CNT" address="0x2" mask="0xffff0000" permission="r"
                description="BX counter underflow count (early BC0 received, one is normal after the
                             TTC module reset, but this should be reset by control software before each run)"
                fw_signal="ttc_status.bc0_status.udf_cnt"
                sw_monitor_error_min_threshold="1"/>
        </node>        
      </node>

      <node id="CMD_COUNTERS" address="0xd"
            description="TTC command counters">
        <node id="L1A" address="0x0" permission="r"
              description="L1A count"
              fw_signal="ttc_cmds_cnt_arr(0)"/>
        <node id="BC0" address="0x1" permission="r"
              description="BC0 count"
              fw_signal="ttc_cmds_cnt_arr(1)"/>
        <node id="EC0" address="0x2" permission="r"
              description="EC0 count"
              fw_signal="ttc_cmds_cnt_arr(2)"/>
        <node id="RESYNC" address="0x3" permission="r"
              description="Resync count"
              fw_signal="ttc_cmds_cnt_arr(3)"/>
        <node id="OC0" address="0x4" permission="r"
              description="OC0 count"
              fw_signal="ttc_cmds_cnt_arr(4)"/>
        <node id="HARD_RESET" address="0x5" permission="r"
              description="Hard-reset count"
              fw_signal="ttc_cmds_cnt_arr(5)"/>
        <node id="CALPULSE" address="0x6" permission="r"
              description="Calibration pulse count"
              fw_signal="ttc_cmds_cnt_arr(6)"/>
        <node id="START" address="0x7" permission="r"
              description="START count"
              fw_signal="ttc_cmds_cnt_arr(7)"/>
        <node id="STOP" address="0x8" permission="r"
              description="STOP count"
              fw_signal="ttc_cmds_cnt_arr(8)"/>
        <node id="TEST_SYNC" address="0x9" permission="r"
              description="Test-sync count"
              fw_signal="ttc_cmds_cnt_arr(9)"/>
      </node>

      <node id="L1A_ID" address="0x17" mask="0x00ffffff" permission="r"
            description="L1A ID (increments with every L1A and resets with EC0), used by DAQ to tag event numbers"
            fw_signal="l1id_cnt"/>

      <node id="L1A_RATE" address="0x18" permission="r"
            description="L1A rate in Hz"
            fw_signal="l1a_rate"/>

      <node id="TTC_SPY_BUFFER" address="0x19" permission="r"
            description="TTC Spy buffer -- this is filled with TTC commands (from LSB to MSB)
                         and freezes until the user reads it out, once read out it resets and
                         fills up again with new TTC commands received from that point on"
            fw_signal="ttc_spy_buffer" fw_read_pulse_signal="ttc_spy_reset"/>
            
      <node id="GENERATOR" address="0x20"
            description="TTC generator that can be used to generate fake single and cyclic commands that may be useful for calibration">
        <node id="RESET" address="0x0" permission="w"
              description="TTC generator module reset"
              fw_write_pulse_signal="gen_reset"/>
        <node id="ENABLE" address="0x1" mask="0x00000001" permission="rw"
              description="Enable TTC generator module. Note that all real TTC commands are suppressed when the generator module is enabled"
              fw_signal="gen_enable" fw_default="0b0"
              sw_ctrl_configure_set="0x0"/>
        <node id="ENABLE_CALPULSE_ONLY" address="0x1" mask="0x00000004" permission="rw"
              description="Enable TTC generator calpulse signal only. Having ENABLE = 0 and ENABLE_CALPULSE_ONLY = 1 will result in using all TTC commands from AMC13 except calpulse, which will be taken from the generator. This is a debugging feature used for synthetic tests which can emulate data coming from the VFATs. If the ENABLE is set to 1, then this register is ignored, and all TTC commands will be taken from the generator."
              fw_signal="gen_enable_cal_only" fw_default="0b0"
              sw_ctrl_configure_set="0x0"/>
        <node id="SINGLE_HARD_RESET" address="0x2" permission="w"
              description="Writing to this register will trigger a single hard-reset command to be sent"
              fw_write_pulse_signal="gen_single_hard_reset"/>
        <node id="SINGLE_RESYNC" address="0x3" permission="w"
              description="Writing to this register will trigger a single resync command to be sent"
              fw_write_pulse_signal="gen_single_resync"/>
        <node id="SINGLE_EC0" address="0x4" permission="w"
              description="Writing to this register will trigger a single EC0 command to be sent"
              fw_write_pulse_signal="gen_single_ec0"/>
        <node id="CYCLIC_L1A_GAP" address="0x1" mask="0x000ffff0" permission="rw"
              description="This register lets you set the number of BXs between cyclic L1A commands"
              fw_signal="gen_cyclic_l1a_gap" fw_default="0x0190"/>
        <node id="CYCLIC_CALPULSE_TO_L1A_GAP" address="0x1" mask="0xfff00000" permission="rw"
              description="This register lets you set the number of BXs between the cyclic CalPulse and the following L1A. Setting this to 0 will disable the cyclic CalPulse"
              fw_signal="gen_cyclic_cal_l1a_gap" fw_default="0x000"/>
        <node id="CYCLIC_CALPULSE_PRESCALE" address="0x7" mask="0x00000fff" permission="rw"
              description="This register lets you prescale the calpulse in relation to L1A. A value of 0 means that there will be a calpulse before every L1A (if the CYCLIC_CALPULSE_TO_L1A_GAP is more than 0) while e.g. a value of 100 means that there will be a calpulse before every 100th L1A."
              fw_signal="gen_cyclic_cal_prescale" fw_default="0x000"/>
        <node id="CYCLIC_L1A_COUNT" address="0x5" mask="0x00ffffff" permission="rw"
              description="This register lets you set the number of cyclic L1As (and calpulses) to be sent uppon cyclic-start command. If this is set to 0 then cyclic L1As will be sent forever uppon cyclic-start command and can only be stopped with a reset or disabling the generator module."
              fw_signal="gen_cyclic_l1a_cnt" fw_default="0x002710"/>
        <node id="CYCLIC_RUNNING" address="0x1" mask="0x00000002" permission="r"
              description="This register indicates if the cyclic generator is running or not"
              fw_signal="gen_cyclic_l1a_running"/>
        <node id="CYCLIC_START" address="0x6" permission="w"
              description="Writing to this register will trigger a start of the cyclic generator"
              fw_write_pulse_signal="gen_cyclic_l1a_start"/>
      </node>
      
    </node>
    <!--end TTC module -->

    <!--Trigger module -->
    <node id="TRIGGER"  address="0x00800000"
          description="Trigger module handles everything related to sbit cluster data
                       (link synchronization, monitoring, local triggering, matching to L1A and reporting data to DAQ)"
          fw_is_module="true"
          fw_module_file="../common/hdl/trigger/trigger.vhd"
          fw_user_clock_signal="ttc_clk_i.clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="12"
          fw_reg_addr_lsb="0">

      <node id="CTRL" address="0x0"
            description="Trigger control">
        <node id="MODULE_RESET" address="0x0" permission="w"
              description="Trigger module reset"
              fw_write_pulse_signal="reset_local"/>
        <node id="CNT_RESET" address="0x1" permission="w"
              description="Trigger counter reset"
              fw_write_pulse_signal="reset_cnt"
              sw_ctrl_configure_set="0x1" sw_ctrl_start_set="0x1"/>
        <node id="OH_KILL_MASK" address="0x2" mask="0x00ffffff" permission="rw"
              description="OH trigger kill mask (kills all sbits from the corresponding OHs)"
              fw_signal="oh_mask"
              fw_default="0x000000"/>
      </node>

      <node id="STATUS" address="0x10"
            description="Trigger status">
        <node id="OR_TRIGGER_RATE" address="0x0" permission="r"
              description="OR-Trigger rate (Hz) -- this trigger fires whenever there's at least one valid sbit cluster on any link"
              fw_signal="or_trigger_rate"
              sw_monitor_warn_min_threshold="1000000"/>
        <node id="OR_TRIGGER_CNT" address="0x1" permission="r"
              description="OR-Trigger count -- this trigger fires whenever there's at least one valid sbit cluster on any link"
              fw_signal="or_trigger_cnt"/>
      </node>

      <node id="SBIT_MONITOR" address="0x80"
            description="sbit monitor module which shows the first valid sbit clusters after a reset on the selected link">
        <node id="RESET" address="0x0" permission="w"
              description="Reset the sbit monitor module and re-arm for triggering"
              fw_write_pulse_signal="sbitmon_reset"/>
        <node id="OH_SELECT" address="0x1" mask="0x0000000f" permission="rw"
              description="Selects the OH to monitor and trigger on"
              fw_signal="sbitmon_link_select"
              fw_default="0x0"/>
        <node id="CLUSTER${CLUSTER_IDX}" address="0x2" mask="0x0000ffff" permission="r"
              description="Last cluster ${CLUSTER_IDX}"
              fw_signal="'0' &amp; sbitmon_sbits(${CLUSTER_IDX}).size &amp; '0' &amp; sbitmon_sbits(${CLUSTER_IDX}).address"
              generate="true" generate_size="8" generate_address_step="0x1" generate_idx_var="CLUSTER_IDX"/>
        <node id="L1A_DELAY" address="0xa" mask="0xffffffff" permission="r"
              description="Number of BX between this sbit and the subsequent L1A"
              fw_signal="sbitmon_l1a_delay"/>
      </node>

      <node id="OH${OH_IDX}" address="0x100"
            description="Trigger link for OH ${OH_IDX}"
            generate="true" generate_size="2" generate_address_step="0x100" generate_idx_var="OH_IDX">
        <node id="TRIGGER_RATE" address="0x0" permission="r"
              description="Trigger rate (Hz) -- this trigger fires whenever there's at least one valid sbit cluster"
              fw_signal="trigger_rate(${OH_IDX})"
              sw_monitor_warn_min_threshold="1000000"/>
        <node id="TRIGGER_CNT" address="0x1" permission="r"
              description="Trigger count -- this trigger fires whenever there's at least one valid sbit cluster"
              fw_signal="trigger_cnt(${OH_IDX})"
              sw_monitor_warn_min_threshold="1000000"/>
        <node id="CLUSTER_SIZE_${CS_IDX}_RATE" address="0x10" permission="r"
              description="Rate of cluster size ${CS_IDX} (size 0 means no sbit clusters)"
              fw_signal="cluster_cnt_rate(${OH_IDX} * 9 + ${CS_IDX})"
              generate="true" generate_size="9" generate_address_step="0x1" generate_idx_var="CS_IDX"/>
        <node id="CLUSTER_SIZE_${CS_IDX}_CNT" address="0x20" permission="r"
              description="Count of cluster size ${CS_IDX} (size 0 means no sbit clusters)"
              fw_signal="cluster_cnt(${OH_IDX} * 9 + ${CS_IDX})"
              generate="true" generate_size="9" generate_address_step="0x1" generate_idx_var="CS_IDX"/>
        <node id="LINK0_SBIT_OVERFLOW_CNT" address="0xa0" mask="0x0000ffff" permission="r"
              description="Count of overflow markers received from OH on lin 0"
              fw_signal="sbit_overflow_cnt(${OH_IDX})(15 downto 0)"
              sw_monitor_error_min_threshold="100"/>
        <node id="LINK1_SBIT_OVERFLOW_CNT" address="0xa0" mask="0xffff0000" permission="r"
              description="Count of overflow markers received from OH on link 1"
              fw_signal="sbit_overflow_cnt(${OH_IDX})(31 downto 16)"
              sw_monitor_error_min_threshold="100"/>
        <node id="LINK0_MISSED_COMMA_CNT" address="0xa1" mask="0x0000ffff" permission="r"
              description="Count of missed comma character at the expected time for link 0 (this indicates an out-of-sync condition)"
              fw_signal="missed_comma_cnt(${OH_IDX})(15 downto 0)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK1_MISSED_COMMA_CNT" address="0xa1" mask="0xffff0000" permission="r"
              description="Count of missed comma character at the expected time for link 1 (this indicates an out-of-sync condition)"
              fw_signal="missed_comma_cnt(${OH_IDX})(31 downto 16)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK0_OVERFLOW_CNT" address="0xa3" mask="0x0000ffff" permission="r"
              description="Count of overflow occurances in the sync FIFO for link 0"
              fw_signal="link_overflow_cnt(${OH_IDX})(15 downto 0)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK1_OVERFLOW_CNT" address="0xa3" mask="0xffff0000" permission="r"
              description="Count of overflow occurances in the sync FIFO for link 1"
              fw_signal="link_overflow_cnt(${OH_IDX})(31 downto 16)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK0_UNDERFLOW_CNT" address="0xa4" mask="0x0000ffff" permission="r"
              description="Count of underflow occurances in the sync FIFO for link 0"
              fw_signal="link_underflow_cnt(${OH_IDX})(15 downto 0)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK1_UNDERFLOW_CNT" address="0xa4" mask="0xffff0000" permission="r"
              description="Count of underflow occurances in the sync FIFO for link 1"
              fw_signal="link_underflow_cnt(${OH_IDX})(31 downto 16)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK0_SYNC_WORD_CNT" address="0xa5" mask="0x0000ffff" permission="r"
              description="Count of sync words seen on link 0"
              fw_signal="sync_word_cnt(${OH_IDX})(15 downto 0)"/>
        <node id="LINK1_SYNC_WORD_CNT" address="0xa5" mask="0xffff0000" permission="r"
              description="Count of sync words seen on link 1"
              fw_signal="sync_word_cnt(${OH_IDX})(31 downto 16)"/>
      </node>

    </node>
    <!--end trigger module -->

    <!--GEM System module -->
    <node id="GEM_SYSTEM"  address="0x00900000"
          description="This module is controlling GEM AMC System wide settings"
          fw_is_module="true"
          fw_module_file="../common/hdl/misc/gem_system_regs.vhd"
          fw_user_clock_signal="ttc_clks_i.clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="16"
          fw_reg_addr_lsb="0">

      <node id="CTRL" address="0x100">
        <node id="CNT_RESET" address="0x0" permission="w"
              description="GEM system counters reset"
              fw_write_pulse_signal="reset_cnt"
              sw_ctrl_configure_set="0x1" sw_ctrl_start_set="0x1"/>
        <node id="LINK_RESET" address="0x1" permission="w"
              description="Reset the links to and from OHs and redo VFAT3 sync procedure"
              fw_write_pulse_signal="manual_link_reset_o"
              sw_ctrl_configure_set="0x1"/>
      </node>

      <node id="BOARD_ID" address="0x2" mask="0x0000ffff" permission="rw"
            description="Board ID that gets embedded in the AMC13 header"
            fw_signal="board_id" fw_default="0xbeef"/>
      <node id="BOARD_TYPE" address="0x2" mask="0x000f0000" permission="r"
            description="Board type: 0 means GLIB, 1 means CTP7"
            fw_signal="board_type"/>

      <node id="RELEASE" address="0x3">
        <node id="MAJOR" address="0x0" mask="0x00ff0000" permission="r"
              description="Firmware release major version"
              fw_signal="std_logic_vector(to_unsigned(version_major, 8))"/>
        <node id="MINOR" address="0x0" mask="0x0000ff00" permission="r"
              description="Firmware release minor version"
              fw_signal="std_logic_vector(to_unsigned(version_minor, 8))"/>
        <node id="BUILD" address="0x0" mask="0x000000ff" permission="r"
              description="Firmware release build version"
              fw_signal="std_logic_vector(to_unsigned(version_build, 8))"/>
        <node id="GEM_STATION" address="0x0" mask="0x03000000" permission="r"
              description="GEM station that this firmware was compiled for (0 means ME0, 1 means GE1/1, 2 means GE2/1)"
              fw_signal="std_logic_vector(to_unsigned(gem_station, 2))"/>
        <node id="DATE" address="0x1" permission="r"
              description="Firmware release date (read as hex)"
              fw_signal="firmware_date"/>
      </node>

      <node id="CONFIG" address="0x5">
        <node id="NUM_OF_OH" address="0x0" mask="0x0000001f" permission="r"
              description="Number of supported optohybrids"
              fw_signal="num_of_oh"/>
      </node>

      <node id="VFAT3" address="0x10">
        <node id="SC_ONLY_MODE" address="0x1" mask="0x00000002" permission="rw"
              description="When this is set to 0 then comm port of VFAT3s will be set to normal mode, otherwise they will be set to slow-control-only mode. This setting is applied to all VFATs during link reset and whenever this value is changed."
              fw_signal="vfat3_sc_only_mode" fw_default="0b0"/>
        <node id="USE_OH_V3B_MAPPING" address="0x1" mask="0x00000004" permission="rw"
              description="If set high, then will use the v3b elink assignments for the OH FPGA communication, otherwise v3a"
              fw_signal="use_v3b_elink_mapping" fw_default="0b1"/>
      </node>

      <node id="TESTS" address="0x200">
        <node id="GBT_LOOPBACK_EN" address="0x0" mask="0x00000001" permission="rw"
              description="GBT Loopback test enable -- if this is true then all GBT links are redirected to the loopback test
                           module and the test module is enabled (communication with optohybrid is not possible during the test)"
              fw_signal="loopback_gbt_test_en" fw_default="0b0"
              sw_ctrl_configure_set="0x0" sw_ctrl_start_set="0x0"/>
      </node>

      <node id="GEM_LOADER" address="0x400">
        <node id="LOAD_REQUEST_CNT" address="0x0" mask="0x0000ffff" permission="r"
              description="Number of OH programming requests (note, the counter is 16bit rolling)"
              fw_signal="gemloader_stats_i.load_request_cnt"/>
        <node id="LOAD_SUCCESS_CNT" address="0x0" mask="0xffff0000" permission="r"
              description="Number of successful OH programming attempts (note, the counter is 16bit rolling)"
              fw_signal="gemloader_stats_i.success_cnt"/>
        <node id="LOAD_FAIL_CNT" address="0x1" mask="0x0000ffff" permission="r"
              description="Number of failed OH programming attempts (note, the counter is 16bit rolling)"
              fw_signal="gemloader_stats_i.fail_cnt"/>
        <node id="STREAM_GAP_CNT" address="0x1" mask="0xffff0000" permission="r"
              description="Number of times that a gap has been detected in the bitfile stream before reaching the end (note, the counter is 16bit rolling)"
              fw_signal="gemloader_stats_i.gap_detect_cnt"/>
        <node id="LOADER_OVF_UNF_CNT" address="0x2" mask="0x0000ffff" permission="r"
              description="Number of times that the gemloader IP has reported a FIFO overflow or underflow (note, the counter is 16bit rolling)"
              fw_signal="gemloader_stats_i.loader_ovf_unf_cnt"/>
      </node>

      <node id="LEGACY_SYSTEM" address="0x10000"
            description="Legacy system registers (taken from GLIB system core). These should be removed once the software is
                         made compatible with the new system registers.">

        <node id="BOARD_ID" address="0x0" permission="r"
              description="GLIB Board ID code"
              fw_signal="legacy_board_id"/>
        <node id="SYSTEM_ID" address="0x1" permission="r"
              description="GLIB System ID code"
              fw_signal="legacy_sys_id"/>
        <node id="FIRMWARE_VERSION" address="0x2" permission="r"
              description="GLIB firmware version + firmware date"
              fw_signal="legacy_fw_version"/>
      </node>
    </node>

    <!--GEM Tests module -->
    <node id="GEM_TESTS"  address="0x00A00000"
          description="This module is controlling various hardware tests e.g. fiber loopback"
          fw_is_module="true"
          fw_module_file="../common/hdl/tests/gem_tests.vhd"
          fw_user_clock_signal="ttc_clk_i.clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="16"
          fw_reg_addr_lsb="0">

      <node id="CTRL" address="0x0">
        <node id="RESET" address="0x0" permission="w"
              description="reset all test modules"
              fw_write_pulse_signal="reset_local"/>
      </node>

      <node id="OH_LOOPBACK" address="0x1000"
              description="This module controls the OH PRBS loopback tester (this tester can be connected to one OH at a time by using the OH_SELECT register). This module sends a PRBS7 8b sequence to all elinks of the chosen OH, and checks each elink of that OH with the same sequence checker">
        <node id="CTRL" address="0x0">
          <node id="RESET" address="0x0" permission="w"
                description="reset the PRBS loopback module"
                fw_write_pulse_signal="gbt_loop_reset"/>
          <node id="OH_SELECT" address="0x1" mask="0x0000000f" permission="rw"
		        description="This register sets the index of the OH that the loopback tester is going to be testing"
		        fw_signal="gbt_loop_oh_select" fw_default="0x0"/>
          <node id="INJECT_ERR" address="0x2" permission="w"
		        description="Writing to this register will result in one error being injected to the PRBS TX data going to the OH"
            fw_write_pulse_signal="gbt_loop_err_inject"/>
        </node>
        <node id="GBT_${GBT_IN_OH_IDX}"  address="0x10"
              description="Link specific registers for GBT ${GBT_IN_OH_IDX}"
              generate="true" generate_size="3" generate_address_step="0x100" generate_idx_var="GBT_IN_OH_IDX">

          <node id="ELINK_${ELINK_IDX}"  address="0x0"
                description="E-link specific registers for e-link ${ELINK_IDX}"
                generate="true" generate_size="14" generate_address_step="0x2" generate_idx_var="ELINK_IDX">

            <node id="PRBS_LOCKED" mask="0x80000000" permission="r" address="0x0"
                  description="Indicates whether or not the PRBS7 checker is locked on this elink"
                  fw_signal="gbt_loop_locked_arr(${GBT_IN_OH_IDX} * 14 + ${ELINK_IDX})"/>
            <node id="MEGA_WORD_CNT" permission="r" address="0x1"
                  description="Number of generated data words in units of one million received by this RX elink after PRBS checker has locked"
                  fw_signal="gbt_loop_mega_word_cnt_arr(${GBT_IN_OH_IDX} * 14 + ${ELINK_IDX})"/>
            <node id="ERROR_CNT" mask="0x7fffffff" permission="r" address="0x0"
                  description="Number of PRBS7 errors found in the received data for this elink"
                  fw_signal="gbt_loop_error_cnt_arr(${GBT_IN_OH_IDX} * 14 + ${ELINK_IDX})(30 downto 0)"/>
          </node>
        </node>
      </node>

      <node id="VFAT_DAQ_MONITOR" address="0x2000"
              description="This module listens to the DAQ data of 24 VFATs from a selected OH 
                           and counts the number of good events received and the number of times a selected channel (or any channel) has fired.
                           This is useful for various scan routines.">
        <node id="CTRL" address="0x0">
          <node id="RESET" address="0x0" permission="w"
                description="reset all the VFAT DAQMON modules"
                fw_write_pulse_signal="vfat_daqmon_reset"/>
	      <node id="ENABLE" address="0x1" mask="0x00000001" permission="rw"
		        description="This register lets you enable and disable all VFAT DAQMON modules. When disabled all the counters are frozen."
		        fw_signal="vfat_daqmon_enable" fw_default="0b0"/>
	      <node id="OH_SELECT" address="0x1" mask="0x000000f0" permission="rw"
		        description="Selects the desired OH"
		        fw_signal="vfat_daqmon_oh_select" fw_default="0x0"/>
	      <node id="VFAT_CHANNEL_SELECT" address="0x1" mask="0x00007f00" permission="rw"
		        description="Selects the VFAT channel number to listen to"
		        fw_signal="vfat_daqmon_chan_select" fw_default="0x0"/>
	      <node id="VFAT_CHANNEL_GLOBAL_OR" address="0x1" mask="0x00008000" permission="rw"
		        description="If this is set to 1 then the VFAT DAQMONs will OR all the VFAT channels together and ignore the VFAT_CHANNEL_SELECT"
		        fw_signal="vfat_daqmon_chan_global_or" fw_default="0x0"/>
        </node>
        <node id="VFAT${VFAT_IDX}"  address="0x10"
              description="VFAT DAQMON counters for VFAT${VFAT_IDX}"
              generate="true" generate_size="24" generate_address_step="0x10" generate_idx_var="VFAT_IDX">

          <node id="GOOD_EVENTS_COUNT" mask="0x0000ffff" permission="r" address="0x0"
                description="Number of good events received from this VFAT (good event means that CRC check has passed ok)"
                fw_signal="vfat_daqmon_good_evt_cnt_arr(${VFAT_IDX})"/>
          <node id="CHANNEL_FIRE_COUNT" mask="0xffff0000" permission="r" address="0x0"
                description="Number of times the selected channel has fired"
                fw_signal="vfat_daqmon_chan_fire_cnt_arr(${VFAT_IDX})"/>

        </node>
      </node>

    </node>

    <!--DAQ module -->
    <node id="DAQ"  address="0x00700000"
          description="DAQ module buffers track data, builds events, analyses the data for consistency
                       and ships off the events with all the needed headers and trailers to AMC13 over DAQLink"
          fw_is_module="true"
          fw_module_file="../common/hdl/daq/daq.vhd"
          fw_user_clock_signal="ipb_clk_i"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="8"
          fw_reg_addr_lsb="0">

      <node id="CONTROL"  address="0x0"
            description="DAQ Control">
        <node id="DAQ_ENABLE"         address="0x0" mask="0x00000001" permission="rw"
              description="If this is set to 0, there will be no data sent to AMC13 and TTS state will always be READY (0x8)"
              fw_signal="daq_enable" fw_default="0b0"/>
        <node id="DAQ_LINK_RESET"     address="0x0" mask="0x00000004" permission="rw"
              description="Directly connected to DAQLink module reset port. BU is
                           advising against ever using it except for powerup, but it
                           may clear some error conditions (like daqlink_almost_ful
                           stuck at 1). AMC13 reset is probably required after this."
              fw_signal="reset_daqlink_ipb" fw_default="0b0"/>
        <node id="RESET"              address="0x0" mask="0x00000008" permission="rw"
              description="Clears all FIFOs, state flags and counters. It also stops and
                           resets all state machines (no events will be built, recorded
                           or sent during reset)
                           When set to 1, it will be held in reset state until 0 is
                           explicitly written (this can be changed in the future if
                           necessary)"
              fw_signal="reset_local" fw_default="0b0"/>
        <node id="ZERO_SUPPRESSION_EN"              address="0x0" mask="0x00000002" permission="rw"
              description="Enable/disable VFAT2 zero suppression"
              fw_signal="zero_suppression_en" fw_default="0b0"/>
        <node id="TTS_OVERRIDE"       address="0x0" mask="0x000000f0" permission="rw"
              description="When not 0, it will override the AMC TTS state with the
                           provided value (e.g. writing 0x8 will force AMC to always be
                           in TTS READY state)"
              fw_signal="tts_override" fw_default="0x0"/>
        <node id="INPUT_ENABLE_MASK"  address="0x0" mask="0xffffff00" permission="rw"
              description="This is a bitmask telling AMC to enable certain inputs (least
                           significant bit is input 0). Only first is enabled by default"
              fw_signal="input_mask" fw_default="0x1"/>
        <node id="DAV_TIMEOUT"        address="0x1"  mask="0x00ffffff" permission="rw"
              description="This setting controls how long DAQ will wait for individual
                           inputs to report data before calling it timed-out  (if timeout
                           occurs a header and trailer for that chamber will still be
                           inserted and timeout flag will be set there, though no VFAT
                           payload will be present). Units = clock cycles @ 25MHz
                           (current DAQLink clk frequency)"
              fw_signal="dav_timeout" fw_default="0x00500"/>
        <node id="DBG_FANOUT_ENABLE"        address="0x1"  mask="0x01000000" permission="rw"
              description="This register enables and disables the fanout feature.
                           This feature is used for testing only. When enabled it will
                           take the data input from one OH and fan it out to all DAQ module
                           inputs. The input to be used is controlled by DBG_FANOUT_INPUT reg."
              fw_signal="dbg_fanout_enable" fw_default="0b0"/>
        <node id="DBG_FANOUT_INPUT"        address="0x1"  mask="0xf0000000" permission="rw"
              description="Selects the input to be faned out when the fanout feature is enabled (see DBG_FANOUT_ENABLE)."
              fw_signal="dbg_fanout_input" fw_default="0x0"/>
        <node id="DBG_IGNORE_DAQLINK"        address="0x1"  mask="0x02000000" permission="rw"
              description="This register when set to 1 will cause the DAQ module to ignore the DAQLink ready and DAQLink backpressure signals.
                           It can be used for fake datarate testing without involving AMC13."
              fw_signal="dbg_daqlink_ignore" fw_default="0b0"/>
        <node id="CALIBRATION_MODE_EN"       address="0x2"  mask="0x00000080" permission="rw"
              description="When set, this enables calibration mode data format, which strips the VFAT payload of most of the data, just leaving 8 bits per VFAT, where [4:0] is the VFAT position, [6:5] is EC, and bit 7 is the chanel information for the channel selected in CALIBRATION_MODE_CHAN (see below)"
              fw_signal="format_calib_mode" fw_default="0b0"/>
        <node id="CALIBRATION_MODE_CHAN"       address="0x2"  mask="0x0000007f" permission="rw"
              description="Channel number for which data will be included in the calibration mode data format (see CALIBRATION_MODE_EN)"
              fw_signal="format_calib_chan" fw_default="0b0000000"/>
      </node>

      <node id="EXT_CONTROL"  address="0x40"
            description="DAQ global extended configuration registers">
        <node id="RUN_TYPE"       address="0x0"  mask="0x0f000000" permission="rw"
              description="User settable run type that gets embedded into the AMC header"
              fw_signal="run_type" fw_default="0x0"/>
        <node id="RUN_PARAMS"     address="0x0"  mask="0x00ffffff" permission="rw"
              description="User settable run params that gets embedded into the AMC header"
              fw_signal="run_params" fw_default="0x000000"/>
      </node>

      <node id="STATUS"  address="0x50"
            description="DAQ global status registers">
        <node id="DAQ_LINK_RDY"    address="0x0"  mask="0x00000001" permission="r"
              description="When this is 1, it means that AMC is in good communication
                           with AMC13. It must be 1 for AMC to be able to send data."
              fw_signal="daq_ready"/>
        <node id="DAQ_CLK_LOCKED"  address="0x0"  mask="0x00000002" permission="r"
              description="This flag is 1 if DAQ clock is locked at this moment"
              fw_signal="daq_clk_locked_i"/>
        <node id="TTC_RDY"         address="0x0"  mask="0x00000004" permission="r"
              description="This flag is 1 if TTC clock MMCM is locked"
              fw_signal="ttc_status_i.mmcm_locked"/>
        <node id="DAQ_LINK_AFULL"       address="0x0"  mask="0x00000008" permission="r"
              description="This bit comes directly from DAQLink module, indicating
                           that its internal buffers are almost full. No events will be sent
                           when this bit is 1 (though events can still be built and
                           stored in the Input and Event FIFOs)"
              fw_signal="daq_almost_full"
              sw_monitor_error_min_threshold="1"/>
        <node id="DAQ_OUTPUT_FIFO_HAD_OVERFLOW"       address="0x0"  mask="0x00000010" permission="r"
              description="This bit is set if DAQ output FIFO has ever been full (critical -- data loss)"
              fw_signal="err_daqfifo_full"
              sw_monitor_error_min_threshold="1"/>
        <node id="TTC_BC0_LOCKED"       address="0x0"  mask="0x00000020" permission="r"
              description="This bit is set if BC0 is currently locked (last BC0 arrived at the expected time)"
              fw_signal="ttc_status_i.bc0_status.locked"/>
        <node id="L1A_FIFO_HAD_OVERFLOW"       address="0x0"  mask="0x00800000" permission="r"
              description="This bit is latched whenever L1A FIFO overflow is asserted.
                           This means that one or more L1As were lost, so we are
                           out-of-sync: resync or reset is needed"
              fw_signal="err_l1afifo_full"
              sw_monitor_error_min_threshold="1"/>
        <node id="L1A_FIFO_IS_UNDERFLOW"       address="0x0"  mask="0x01000000" permission="r"
              description="L1A FIFO is in underflow at this moment (this bit is not latched)"
              fw_signal="l1afifo_underflow"
              sw_monitor_error_min_threshold="1"/>
        <node id="L1A_FIFO_IS_FULL"       address="0x0"  mask="0x02000000" permission="r"
              description="L1A FIFO is full at this moment (this bit is not latched)"
              fw_signal="l1afifo_full"
              sw_monitor_error_min_threshold="1"/>
        <node id="L1A_FIFO_IS_NEAR_FULL"       address="0x0"  mask="0x04000000" permission="r"
              description="This bit gets asserted when L1A FIFO gets 75% full and deasserted when it gets down to 50%"
              fw_signal="l1afifo_near_full"/>
        <node id="L1A_FIFO_IS_EMPTY"       address="0x0"  mask="0x08000000" permission="r"
              description="L1A FIFO is empty at this moment (this bit is not latched)"
              fw_signal="l1afifo_empty"/>
        <node id="TTS_STATE"       address="0x0"  mask="0xf0000000" permission="r"
              description="Current TTS state (READY, BUSY, ERROR, WARN, OUT-OF-SYNC)"
              fw_signal="tts_state"/>
      </node>

      <node id="EXT_STATUS"  address="0x80"
            description="DAQ global extended status registers">
        <node id="NOTINTABLE_ERR"  address="0x0"  mask="0x0000ffff" permission="r"
              description="This counter is counting DAQLink GTX/GTH not-in-table errors"
              fw_signal="daq_notintable_err_cnt"/>
        <node id="DISPER_ERR"      address="0x1"  mask="0x0000ffff" permission="r"
              description="This counter is counting DAQLink GTX/GTH dispersion errors"
              fw_signal="daq_disper_err_cnt"/>
        <node id="L1AID"           address="0x2"  mask="0x00ffffff" permission="r"
              description="Current L1A ID (similar to event number, but this may be a bit ahead of
                           that if we're still waiting for data for unprocessed L1As)"
              fw_signal="ttc_daq_cntrs_i.l1id"/>
        <node id="EVT_SENT"        address="0x3"  permission="r"
              description="Number of events shipped out to DAQLink"
              fw_signal="std_logic_vector(cnt_sent_events)"/>
        <node id="MAX_DAV_TIMER"   address="0x5"  mask="0x00ffffff" permission="r"
              description="This indicates the maximum amount of time that DAQ had
                           to wait for all inputs to report data (can be used to optimize
                           DAV timeout setting). Units = clock cycles @ DAQ clock frequency (currently using 40.08MHz TTC clock)
                           (current DAQLink clk frequency)"
              fw_signal="std_logic_vector(max_dav_timer)"/>
        <node id="LAST_DAV_TIMER"  address="0x6"  mask="0x00ffffff" permission="r"
              description="This indicates how DAQ had to wait for all inputs to report
                           data for the last event (mostly for debugging). Units = clock
                           cycles @ DAQ clock frequency (currently using 40.08MHz TTC clock)"
              fw_signal="std_logic_vector(last_dav_timer)"/>
        <node id="L1A_FIFO_DATA_CNT"  address="0x7"  mask="0x00001fff" permission="r"
              description="Current number of words in the L1A FIFO (current depth is 8192)"
              fw_signal="l1afifo_data_cnt"/>
        <node id="DAQ_FIFO_DATA_CNT"  address="0x7"  mask="0x1fff0000" permission="r"
              description="Current number of words in the DAQ output FIFO (current depth is 8192)"
              fw_signal="daqfifo_data_cnt"/>
        <node id="L1A_FIFO_NEAR_FULL_CNT"  address="0x8"  mask="0x0000ffff" permission="r"
              description="Number of clocks L1A FIFO was near-full (asserted at 75%, deasserted at 50%)"
              fw_signal="l1afifo_near_full_cnt"
              sw_monitor_warn_min_threshold="100"/>
        <node id="DAQ_FIFO_NEAR_FULL_CNT"  address="0x8"  mask="0xffff0000" permission="r"
              description="Number of clocks DAQ output FIFO was near-full (asserted at 75%, deasserted at 50%)"
              fw_signal="daqfifo_near_full_cnt"
              sw_monitor_warn_min_threshold="100"/>
        <node id="DAQ_ALMOST_FULL_CNT"  address="0x9"  mask="0x0000ffff" permission="r"
              description="Number of clocks DAQLink has asserted almost-full flag"
              fw_signal="daqlink_afull_cnt"/>
        <node id="TTS_WARN_CNT"  address="0x9"  mask="0xffff0000" permission="r"
              description="Number of clocks we reported TTS WARNING state"
              fw_signal="tts_warning_cnt"
              sw_monitor_warn_min_threshold="100"/>
        <node id="DAQ_WORD_RATE"  address="0xa"  permission="r"
              description="Rate of 64bit words being sent out to the DAQLink in Hz (multiply by 64 to get bitrate)"
              fw_signal="daq_word_rate"
              sw_monitor_warn_min_threshold="40000"/> <!-- currently running DAQ at 50MHz, which is 3.2Gbs, so warning at 2.5Gbs (could increase to 80MHz to get 5Gbs) -->
      </node>

      <node id="OH${OH_IDX}"  address="0x100"
            description="Link specific registers for OH${OH_IDX}"
            generate="true" generate_size="2" generate_address_step="0x10" generate_idx_var="OH_IDX">

        <node id="CONTROL"  address="0x0">
          <node id="EOE_TIMEOUT" address="0x3"  mask="0x00ffffff" permission="rw"
                description="Units = clock cycles @ 160MHz.
                             If no new data was received in this amount of time, AMC
                             will close the current event and report it to DAQ. This is one
                             of the two ways to close an event, the other is to get new
                             data with different BX number"
                fw_signal="input_control_arr(${OH_IDX}).eb_timeout_delay" fw_default="0x000100"/>
        </node>

        <node id="STATUS"  address="0x0">
          <node id="VFAT_MIXED_EC"    mask="0x00000002" permission="r" address="0x0"
                description="There was at least one event with mixed VFAT Event IDs"
                fw_signal="input_status_arr(${OH_IDX}).err_mixed_vfat_ec"/>
          <node id="VFAT_MIXED_BC"  mask="0x00000004" permission="r" address="0x0"
                description="There was at least one event with mixed VFAT BX IDs"
                fw_signal="input_status_arr(${OH_IDX}).err_mixed_vfat_bc"/>
          <node id="OH_MIXED_BC"         mask="0x00000008" permission="r" address="0x0"
                description="There was at least one event with mixed OH BX IDs (OH BX
                             ID is reported for every VFAT block, but not sent to
                             AMC13)."
                fw_signal="input_status_arr(${OH_IDX}).err_mixed_oh_bc"/>

          <node id="VFAT_TOO_MANY"      mask="0x00000010" permission="r" address="0x0"
                description="Corruption: more than 24 VFATs in event"
                fw_signal="input_status_arr(${OH_IDX}).err_event_bigger_than_24"/>
          <node id="VFAT_SMALL_BLOCK"   mask="0x00000020" permission="r" address="0x0"
                description="Corruption: VFAT block smaller than 192bits"
                fw_signal="input_status_arr(${OH_IDX}).err_vfat_block_too_small"/>
          <node id="VFAT_LARGE_BLOCK"   mask="0x00000040" permission="r" address="0x0"
                description="Corruption: VFAT block bigger than 192bits"
                fw_signal="input_status_arr(${OH_IDX}).err_vfat_block_too_big"/>
          <node id="VFAT_NO_MARKER"     mask="0x00000080" permission="r" address="0x0"
                description="Corruption: VFAT marker not detected.
                             There was at least one VFAT block not conforming to the
                             pattern of Axxx Cxxx Exxx... (see VFAT data format)
                             Note that this data will still be included in the current event
                             and sent to AMC13, but it will not be considered in
                             end-of-event detection"
                fw_signal="input_status_arr(${OH_IDX}).err_corrupted_vfat_data"/>
          <node id="INPUT_FIFO_HAD_OFLOW"   mask="0x00000100" permission="r" address="0x0"
                description="Critical: Input FIFO overflow occurred.
                             This bit is latched if Input FIFO was ever full when receiving
                             new data - this means data was lost.
                             TTS ERROR is asserted when this bit is 1"
                fw_signal="input_status_arr(${OH_IDX}).err_infifo_full"/>
          <node id="INPUT_FIFO_HAD_UFLOW"   mask="0x00000200" permission="r" address="0x0"
                description="Critical: Input FIFO underflow occurred.
                             This bit is latched if Input FIFO underflow was ever
                             detected. This means that Event FIFO indicated that there
                             should be more data than was stored in Input FIFO. This
                             might happen due to overflow or some other malfunction.
                             TTS ERROR is asserted when this bit is 1"
                fw_signal="input_status_arr(${OH_IDX}).err_infifo_underflow"/>
          <node id="EVENT_FIFO_HAD_OFLOW"   mask="0x00000400" permission="r" address="0x0"
                description="Critical: Event FIFO overflow occurred.
                             This bit is latched if Event FIFO was ever full when trying to
                             build a new event. This means data was lost.
                             It's not likely that this will ever be asserted because Input
                             FIFO should overflow first.
                             TTS ERROR is asserted when this bit is 1"
                fw_signal="input_status_arr(${OH_IDX}).err_evtfifo_full"/>
          <node id="EVT_SIZE_ERR"           mask="0x00000800" permission="r" address="0x0"
                description="Critical: Event size overflow occurred.
                             This bit is latched if there was an event containing more
                             than 4096 VFAT blocks. Input FIFO and Event FIFO will be
                             out-of-sync. This might happen if end-of-event is not
                             detected properly or for whatever reason AMC is receiving
                             a stream of VFAT blocks indicating that they belong to the
                             same event (EC/BC is the same)
                             TTS ERROR is asserted when this bit is 1"
                fw_signal="input_status_arr(${OH_IDX}).err_event_too_big"/>
          <node id="VFAT_INPUT_HAD_OVF"           mask="0x00010000" permission="r" address="0x0"
                description="Individual VFAT input buffer had overflow. This indicates a logic problem in the firmware and therefore is a critical error"
                fw_signal="input_status_arr(${OH_IDX}).vfat_fifo_ovf"/>
          <node id="VFAT_INPUT_HAD_UNF"           mask="0x00020000" permission="r" address="0x0"
                description="Individual VFAT input buffer had underflow. This indicates a logic problem in the firmware and therefore is a critical error"
                fw_signal="input_status_arr(${OH_IDX}).vfat_fifo_unf"/>
          <node id="TTS_STATE"           mask="0x0000f000" permission="r" address="0x0"
                description="Input TTS state (gets integrated into global TTS state later)"
                fw_signal="input_status_arr(${OH_IDX}).tts_state"/>
          <node id="INPUT_FIFO_IS_UFLOW"    mask="0x01000000" permission="r" address="0x0"
                description="Current status: Input FIFO is in underflow"
                fw_signal="input_status_arr(${OH_IDX}).infifo_underflow"/>
          <node id="INPUT_FIFO_IS_FULL"     mask="0x02000000" permission="r" address="0x0"
                description="Current status: Input FIFO is full"
                fw_signal="input_status_arr(${OH_IDX}).infifo_full"/>
          <node id="INPUT_FIFO_IS_AFULL"    mask="0x04000000" permission="r" address="0x0"
                description="Current status: Input FIFO is near-full (asserted at 75% and deasserted at 50%)"
                fw_signal="input_status_arr(${OH_IDX}).infifo_near_full"/>
          <node id="INPUT_FIFO_IS_EMPTY"    mask="0x08000000" permission="r" address="0x0"
                description="Current status: Input FIFO is empty"
                fw_signal="input_status_arr(${OH_IDX}).infifo_empty"/>
          <node id="EVENT_FIFO_IS_UFLOW"    mask="0x10000000" permission="r" address="0x0"
                description="Current status: Event FIFO is in underflow"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_underflow"/>
          <node id="EVENT_FIFO_IS_FULL"     mask="0x20000000" permission="r" address="0x0"
                description="Current status: Event FIFO is full"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_full"/>
          <node id="EVENT_FIFO_IS_AFULL"    mask="0x40000000" permission="r" address="0x0"
                description="Current status: Event FIFO is near-full (asserted at 75% and deasserted at 50%)"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_near_full"/>
          <node id="EVENT_FIFO_IS_EMPTY"    mask="0x80000000" permission="r" address="0x0"
                description="Current status: Event FIFO is empty"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_empty"/>
        </node>

        <node id="COUNTERS">
          <node id="CORRUPT_VFAT_BLK_CNT"  address="0x1" permission="r"
                description="This counter is incremented when a VFAT block does not
                             conform to the pattern of Axxx Cxxx Exxx... (see VFAT
                             data format)
                             Note that this data is still included in events and sent to
                             AMC13, but it does not participate in end-of-event
                             detection."
                fw_signal="input_status_arr(${OH_IDX}).cnt_corrupted_vfat"/>
          <node id="EVN"                   address="0x2" mask="0x00ffffff" permission="r"
                description="Current event number of the event builder.
                             This counter starts at 1 and increments with each
                             end-of-event detection. This number should be similar to
                             the number of events sent to AMC13 in normal operation,
                             but it might not always be exactly the same because there's
                             some latency between building an event and sending it. In
                             addition, event sending could stop due to DAQ FIFO being
                             almost full or DAQLink not being ready."
                fw_signal="input_status_arr(${OH_IDX}).eb_event_num"/>
          <node id="INPUT_FIFO_DATA_CNT"  address="0x4"  mask="0x00000fff" permission="r"
                description="Current number of words in the Input FIFO (current depth is 4096)"
                fw_signal="chamber_infifos(${OH_IDX}).data_cnt"/>
          <node id="EVT_FIFO_DATA_CNT"  address="0x4"  mask="0x0fff0000" permission="r"
                description="Current number of words in the Event FIFO (current depth is 4096)"
                fw_signal="chamber_evtfifos(${OH_IDX}).data_cnt"/>
          <node id="INPUT_FIFO_NEAR_FULL_CNT"  address="0x5"  mask="0x0000ffff" permission="r"
                description="Number of times Input FIFO was near-full (asserted at 75%, deasserted at 50%)"
                fw_signal="input_status_arr(${OH_IDX}).infifo_near_full_cnt"
                sw_monitor_warn_min_threshold="100"/>
          <node id="EVT_FIFO_NEAR_FULL_CNT"  address="0x5"  mask="0xffff0000" permission="r"
                description="Number of times Event FIFO was near-full (asserted at 75%, deasserted at 50%)"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_near_full_cnt"
                sw_monitor_warn_min_threshold="100"/>
          <node id="VFAT_BLOCK_RATE"  address="0x6"  mask="0x00007fff" permission="r"
                description="Rate of VFAT blocks (192bit words) being written to Input FIFO in Hz (multiply by 192 to get bitrate)"
                fw_signal="input_status_arr(${OH_IDX}).infifo_wr_rate"
                sw_monitor_warn_min_threshold="13000"/>
          <node id="EVT_RATE"  address="0x6"  mask="0xffff8000" permission="r"
                description="Rate of events being written to Event FIFO in Hz"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_wr_rate"/>
          <node id="MAX_EOE_TIMER"         address="0x7" mask="0x00ffffff" permission="r"
                description="Units = clock cycles @ 160MHz.
                             This indicates the maximum amount of time that event
                             builder took to build and close the event. Note: this is
                             mostly for debugging, most of the time it should be equal
                             to 'End of event timeout'"
                fw_signal="input_status_arr(${OH_IDX}).eb_max_timer"/>
          <node id="LAST_EOE_TIMER"        address="0x8" mask="0x00ffffff" permission="r"
                description="Units = clock cycles @ 160MHz.
                             This shows how long event builder took to build and close
                             the last event. Note: this is mostly for debugging, but could
                             be used to tune the 'end of event timeout'"
                fw_signal="input_status_arr(${OH_IDX}).eb_last_timer"/>
        </node>

      </node>
    </node>

    <!-- OH link module -->
    <node id="OH_LINKS"  address="0x00600000"
          description="OH Link monitoring registers"
          fw_is_module="true"
          fw_module_file="../common/hdl/oh/oh_link_regs.vhd"
          fw_user_clock_signal="clk_i"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="12"
          fw_reg_addr_lsb="0">

      <node id="OH${OH_IDX}" address="0x100"
            description="Links for OH ${OH_IDX}"
            generate="true" generate_size="2" generate_address_step="0x100" generate_idx_var="OH_IDX">

        <node id="GBT0_READY" address="0x0" mask="0x00000001" permission="r"
              description="If this is set to 1 it means that CTP7 is receiving valid GBT frames from this GBT link"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 0).gbt_rx_ready"
              sw_monitor_error_value="0"/>
        <node id="GBT1_READY" address="0x0" mask="0x00000002" permission="r"
              description="If this is set to 1 it means that CTP7 is receiving valid GBT frames from this GBT link"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 1).gbt_rx_ready"
              sw_monitor_error_value="0"/>
        <node id="GBT2_READY" address="0x0" mask="0x00000004" permission="r" gem_stations="1"
              description="If this is set to 1 it means that CTP7 is receiving valid GBT frames from this GBT link"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 2).gbt_rx_ready"
              sw_monitor_error_value="0"/>

        <node id="GBT0_WAS_NOT_READY" address="0x0" mask="0x00000008" permission="r"
              description="This flag is latched high whenever the GBT link ready goes low, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 0).gbt_rx_had_not_ready"
              sw_monitor_warn_value="0"/>
        <node id="GBT1_WAS_NOT_READY" address="0x0" mask="0x00000010" permission="r"
              description="This flag is latched high whenever the GBT link ready goes low, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 1).gbt_rx_had_not_ready"
              sw_monitor_warn_value="0"/>
        <node id="GBT2_WAS_NOT_READY" address="0x0" mask="0x00000020" permission="r" gem_stations="1"
              description="This flag is latched high whenever the GBT link ready goes low, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 2).gbt_rx_had_not_ready"
              sw_monitor_warn_value="0"/>

        <node id="GBT0_RX_HAD_OVERFLOW" address="0x0" mask="0x00000040" permission="r"
              description="This flag is latched high if the GBT RX sync fifo has overflow, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 0).gbt_rx_sync_status.had_ovf"
              sw_monitor_error_value="0"/>
        <node id="GBT1_RX_HAD_OVERFLOW" address="0x0" mask="0x00000080" permission="r"
              description="This flag is latched high if the GBT RX sync fifo has overflow, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 1).gbt_rx_sync_status.had_ovf"
              sw_monitor_error_value="0"/>
        <node id="GBT2_RX_HAD_OVERFLOW" address="0x0" mask="0x00000100" permission="r" gem_stations="1"
              description="This flag is latched high if the GBT RX sync fifo has overflow, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 2).gbt_rx_sync_status.had_ovf"
              sw_monitor_error_value="0"/>

        <node id="GBT0_RX_HAD_UNDERFLOW" address="0x0" mask="0x00000200" permission="r"
              description="This flag is latched high if the GBT RX sync fifo has underflow, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 0).gbt_rx_sync_status.had_unf"
              sw_monitor_error_value="0"/>
        <node id="GBT1_RX_HAD_UNDERFLOW" address="0x0" mask="0x00000400" permission="r"
              description="This flag is latched high if the GBT RX sync fifo has underflow, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 1).gbt_rx_sync_status.had_unf"
              sw_monitor_error_value="0"/>
        <node id="GBT2_RX_HAD_UNDERFLOW" address="0x0" mask="0x00000800" permission="r" gem_stations="1"
              description="This flag is latched high if the GBT RX sync fifo has underflow, and is reset with link reset"
              fw_signal="gbt_link_status_arr_i(${OH_IDX} * g_NUM_GBTS_PER_OH + 2).gbt_rx_sync_status.had_unf"
              sw_monitor_error_value="0"/>

        <node id="VFAT_MASK" address="0x1" mask="0x00ffffff" permission="rw"
              description="Mask the RX link of the selected VFATs (both slow control and DAQ path will be shut off for these VFATs)."
              fw_signal="vfat_mask_arr(${OH_IDX})" fw_default="0x000000"/>

        <node id="VFAT${VFAT_IDX}" address="0x10"
              description="Link status of VFAT ${VFAT_IDX} on ${OH_IDX}"
              generate="true" generate_size="24" generate_address_step="0x2" generate_idx_var="VFAT_IDX">

          <node id="LINK_GOOD" address="0x0" mask="0x00000001" permission="r"
                description="This flag is set high after detecting 10 consecutive good sync verify replies and set bad after 100 bad ones in a row (sync verify is done once per orbit). This flag can only go high if the initial sync procedure and RX bitslipping was done successfully"
                fw_signal="vfat3_link_status_arr_i(${OH_IDX})(${VFAT_IDX}).sync_good"
                sw_monitor_error_value="0"/>
          <node id="SYNC_ERR_CNT" address="0x0" mask="0x000000f0" permission="r"
                description="This counter counts the total number of times that VFAT3 didn't reply to sync_verify command correctly. This counter doesn't roll over, and is reset on link reset."
                fw_signal="vfat3_link_status_arr_i(${OH_IDX})(${VFAT_IDX}).sync_error_cnt"
                sw_monitor_error_value="0"/>
          <node id="DAQ_EVENT_CNT" address="0x0" mask="0x0000ff00" permission="r"
                description="This counter counts the number of DAQ events received from this VFAT (note that this is an 8bit rolling counter)"
                fw_signal="vfat3_link_status_arr_i(${OH_IDX})(${VFAT_IDX}).daq_event_cnt"/>
          <node id="DAQ_CRC_ERROR_CNT" address="0x0" mask="0x00ff0000" permission="r"
                description="This counter counts the number of CRC errors in the DAQ events received from this VFAT (note that this is an 8bit rolling counter)"
                fw_signal="vfat3_link_status_arr_i(${OH_IDX})(${VFAT_IDX}).daq_crc_err_cnt"
                sw_monitor_warn_value="100"/>

        </node>
        
      </node>
    </node>

    <!--GEM slow control module -->
    <node id="SLOW_CONTROL"  address="0x00B00000"
          description="This module is handling slow control (mainly OH SCA and OH GBTx IC related communication)"
          fw_is_module="true"
          fw_module_file="../common/hdl/slow_control/slow_control.vhd"
          fw_user_clock_signal="ttc_clk_i.clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="16"
          fw_reg_addr_lsb="0">

      <node id="SCA" address="0x0">
        <node id="CTRL" address="0x0">
          <node id="MODULE_RESET" address="0x0" permission="w"
                description="SCA controller reset (coming out of module reset it will also reset and reconfigure the SCA chip)"
                fw_write_pulse_signal="sca_reset"/>
          <node id="OH_FPGA_HARD_RESET" address="0x1" permission="w"
                description="Writing to this register will trigger OH FPGA hard reset"
                fw_write_pulse_signal="manual_hard_reset"/>
          <node id="TTC_HARD_RESET_EN" address="0x2" permission="rw"
                description="This is a bitmask (one bit per OH) that determines whether or not TTC hard reset commands are forwarded to the SCA to reset the OH FPGA (Nth bit set to 1 will enable TTC hard resets to the Nth OH)"
                fw_signal="sca_ttc_hr_enable" fw_default="0xffffffff"/>
          <node id="SCA_RESET_ENABLE_MASK" address="0x3" mask="0xffffffff" permission="rw"
                description="This bitmask defines which SCAs will be reset uppon receipt of MODULE_RESET command."
                fw_signal="sca_reset_mask" fw_default="0xffffffff"/>
        </node>

        <node id="STATUS" address="0x100">
          <node id="READY" address="0x0" mask="0xffffffff" permission="r"
                description="Bits in this register indicate that the SCA controller for the corresponding link has good communication with the SCA chip"
                fw_signal="sca_ready_arr"/>
          <node id="CRITICAL_ERROR" address="0x1" mask="0xffffffff" permission="r"
                description="Bits in this register indicate that the SCA controller for the corresponding link has encountered a critical error (needs reset)"
                fw_signal="sca_critical_error_arr"/>
          <node id="NOT_READY_CNT_OH${OH_IDX}" address="0x2" mask="0x0000ffff" permission="r" 
                description="Counts the number of times that the SCA controller READY signal went to 0 since last SCA reset"
                generate="true" generate_size="2" generate_address_step="0x00000001" generate_idx_var="OH_IDX"
                fw_signal="sca_not_ready_cnt_arr(${OH_IDX})"/>

          <!--node id="RX_ERR_CNT" address="0x1" mask="0x0000ffff" permission="r"
                description="Number of RX errors"
                fw_signal="sca_rx_err_cnt"/>
          <node id="SEQ_NUM_ERR_CNT" address="0x1" mask="0xffff0000" permission="r"
                description="Number of sequence number errors"
                fw_signal="sca_seq_num_err_cnt"/>
          <node id="CRC_ERR_CNT" address="0x2" mask="0x0000ffff" permission="r"
                description="Number of CRC errors"
                fw_signal="sca_crc_err_cnt"/>
          <node id="TRANSACTION_TIMEOUT_CNT" address="0x2" mask="0xffff0000" permission="r"
                description="Number of transaction timeouts"
                fw_signal="sca_tr_timeout_cnt"/>
          <node id="TRANSACTION_FAIL_CNT" address="0x3" mask="0x0000ffff" permission="r"
                description="Number of transaction failures (all retries used up)"
                fw_signal="sca_tr_fail_cnt"/>
          <node id="LAST_SCA_ERROR" address="0x3" mask="0x007f0000" permission="r"
                description="Last error reported by the SCA chip"
                fw_signal="sca_last_sca_error"/>
          <node id="TRANSACTION_DONE_CNT" address="0x4" permission="r"
                description="Number of transactions successfully executed"
                fw_signal="sca_tr_done_cnt"/-->
        </node>

        <node id="MANUAL_CONTROL" address="0x1000">
          <node id="LINK_ENABLE_MASK" address="0x0" mask="0xffffffff" permission="rw"
                description="This is a bitmask of enabled links for the SCA manual command.
                             Multiple channels can be enabled at the same time, which will 
                             result in a broadcast command to these channels when writing to the command registers"
                fw_signal="sca_user_command_en_mask" fw_default="0x00000000"/>
 
          <node id="SCA_CMD" address="0x1">
            <node id="SCA_CMD_CHANNEL" address="0x0" mask="0x000000ff" permission="rw"
                  description="Manual SCA command: channel"
                  fw_signal="sca_user_command.channel" fw_default="0x00"/>
            <node id="SCA_CMD_COMMAND" address="0x0" mask="0x0000ff00" permission="rw"
                  description="Manual SCA command: command"
                  fw_signal="sca_user_command.command" fw_default="0x00"/>
            <node id="SCA_CMD_LENGTH" address="0x0" mask="0x00ff0000" permission="rw"
                  description="Manual SCA command: length (range = 0 to 4)"
                  fw_signal="sca_user_command.length" fw_default="0x00"/>
            <node id="SCA_CMD_DATA" address="0x1" permission="rw"
                  description="Manual SCA command: data"
                  fw_signal="sca_user_command.data" fw_default="0x00000000"/>
            <node id="SCA_CMD_EXECUTE" address="0x2" permission="w"
                  description="Manual SCA command: writing to this register will trigger the execution of the SCA command"
                  fw_write_pulse_signal="sca_user_command_en" fw_write_done_signal="sca_user_command_done_all"/>
          </node>

          <node id="SCA_REPLY_OH${OH_IDX}" address="0x4"
                description="SCA reply for Optohybrid ${OH_IDX}"
                generate="true" generate_size="2" generate_address_step="0x00000002" generate_idx_var="OH_IDX">

            <node id="SCA_RPY_CHANNEL" address="0x0" mask="0x000000ff" permission="r"
                  description="SCA reply to the manual command: channel"
                  fw_signal="sca_user_reply_arr(${OH_IDX}).channel"/>
            <node id="SCA_RPY_ERROR" address="0x0" mask="0x0000ff00" permission="r"
                  description="SCA reply to the manual command: command"
                  fw_signal="sca_user_reply_arr(${OH_IDX}).error"/>
            <node id="SCA_RPY_LENGTH" address="0x0" mask="0x00ff0000" permission="r"
                  description="SCA reply to the manual command: length (range = 0 to 4)"
                  fw_signal="sca_user_reply_arr(${OH_IDX}).length"/>
            <node id="SCA_RPY_DATA" address="0x1" permission="r"
                  description="SCA reply to the manual command: data"
                  fw_signal="sca_user_reply_arr(${OH_IDX}).data"/>
          </node>
        </node>

        <node id="JTAG" address="0x2500">
          <node id="CTRL" address="0x0">
            <node id="ENABLE_MASK" address="0x0" mask="0xffffffff" permission="rw"
                  description="This is a bitmask of enabled links for the SCA JTAG commands.
                               Multiple channels can be enabled at the same time, which will 
                               result in a broadcast command to these channels when writing to the TDO and TMS registers"
                  fw_signal="jtag_enabled_mask" fw_default="0x00000000"/>
            <node id="SHIFT_MSB" address="0x1" mask="0x00000002" permission="rw"
                  description="If this is 1 then SCA will shift out bits MSB to LSB and if this is 0 then LSB to MSB (default)"
                  fw_signal="jtag_shift_msb_first" fw_default="0b0"/>
            <node id="EXPERT" address="0x1">
              <node id="EXEC_ON_EVERY_TDO" address="0x0" mask="0x00000004" permission="rw"
                    description="EXPERT ONLY: used to optimize firmware downloading, when set high the controller will execute
                                 JTAG_GO after every TDO shift (even if length is higher than 32)"
                    fw_signal="jtag_exec_on_every_tdo" fw_default="0b0"/>
              <node id="NO_SCA_LENGTH_UPDATE" address="0x0" mask="0x00000008" permission="rw"
                    description="EXPERT ONLY: used to optimize firmware downloading, when set high the controller will
                                 assume that SCA already has the correct length and will not update it before each JTAG_GO"
                    fw_signal="jtag_no_length_update" fw_default="0b0"/>
              <node id="SHIFT_TDO_ASYNC" address="0x0" mask="0x00000010" permission="rw"
                    description="kindof expert: if this is set high then JTAG controller will acknowledge the TDO shift
                                 command immediately, but if the second command is received while it's still busy it
                                 won't assert jtag_shift_done_o until the previous command is done"
                    fw_signal="jtag_shift_tdo_async" fw_default="0b0"/>
            </node>
          </node>
          <node id="NUM_BITS" address="0x2" mask="0x000007f" permission="rw"
                description="Number of bits in the JTAG command (0 means 128). Once you shift this number of bits of
                             TDO data, the JTAG command will be executed and TDI is available for reading"
                fw_signal="jtag_cmd_length" fw_default="0b0000000"/>
          <node id="TMS" address="0x3" permission="w"
                description="TMS bits to shift to the SCA chip. 32 bits are shifted with each write to this register.
                             The write transaction completes once the bit shifting to the SCA is already done and
                             confirmed by the SCA, so there's no need to sleep between the consecutive writes to this register."
                fw_signal="jtag_tms" fw_write_pulse_signal="jtag_shift_tms_en" fw_write_done_signal="jtag_shift_done_all"
                fw_default="0x00000000"/>
          <node id="TDO" address="0x4" permission="w"
                description="TDO bits to shift to the SCA chip. 32 bits are shifted with each write to this register.
                             Once the number of bits shifted is equal to or greater than the NUM_BITS the JTAG command
                             will be executed. The write transaction completes once the bit shifting to the SCA is
                             already done and confirmed by the SCA, so there's no need to sleep between the consecutive
                             writes to this register."
                fw_signal="jtag_tdo" fw_write_pulse_signal="jtag_shift_tdo_en" fw_write_done_signal="jtag_shift_done_all"
                fw_default="0x00000000"/>

          <node id="TDI_OH${OH_IDX}" address="0x5" permission="r"
                description="When reading this register the TDI bits are shifted from the SCA of OH${OH_IDX} (32 bits with each read)."
                generate="true" generate_size="2" generate_address_step="0x00000001" generate_idx_var="OH_IDX"
                fw_signal="jtag_tdi_arr(${OH_IDX})" fw_read_pulse_signal="jtag_shift_tdi_en_arr(${OH_IDX})" fw_read_ready_signal="jtag_shift_done_arr(${OH_IDX})"/>
        </node>

        <!--node id="DEBUG" address="0x3000">
          <node id="RAW_TX_LAST_CMD_0" address="0x0" permission="r"
                description="Last raw output on the TX, bits [31:0]"
                fw_signal="sca_tx_raw_last_cmd(31 downto 0)"/>
          <node id="RAW_TX_LAST_CMD_1" address="0x1" permission="r"
                description="Last raw output on the TX, bits [63:32]"
                fw_signal="sca_tx_raw_last_cmd(63 downto 32)"/>
          <node id="RAW_TX_LAST_CMD_2" address="0x2" permission="r"
                description="Last raw output on the TX, bits [95:64]"
                fw_signal="sca_tx_raw_last_cmd(95 downto 64)"/>
          <node id="RAW_RX_LAST_RPY_0" address="0x3" permission="r"
                description="Last raw input on the RX, bits [31:0]"
                fw_signal="sca_rx_raw_last_reply(31 downto 0)"/>
          <node id="RAW_RX_LAST_RPY_1" address="0x4" permission="r"
                description="Last raw input on the RX, bits [63:32]"
                fw_signal="sca_rx_raw_last_reply(63 downto 32)"/>
          <node id="RAW_RX_LAST_RPY_2" address="0x5" permission="r"
                description="Last raw input on the RX, bits [95:64]"
                fw_signal="sca_rx_raw_last_reply(95 downto 64)"/>
          <node id="RX_LAST_CALC_CRC" address="0x6" mask="0x0000ffff" permission="r"
                description="RX last calculated CRC"
                fw_signal="sca_rx_last_calc_crc"/>
        </node-->

      </node>

      <node id="IC" address="0x3000">
        <node id="ADDRESS" address="0x0" mask="0x0000ffff" permission="rw"
              description="GBTx register address to read or write"
              fw_signal="ic_address" fw_default="0x0000"/>
        <node id="READ_WRITE_LENGTH" address="0x1" mask="0x00000007" permission="rw"
              description="Number of data bytes to be written or read e.g. if you set it to 4 then 4 consecutive
                           GBTx registers will be written with the 4 bytes in WRITE_DATA register. Max is 4."
              fw_signal="ic_rw_length" fw_default="0x01"/>
        <node id="WRITE_DATA" address="0x2" permission="rw"
              description="GBTx register value to write"
              fw_signal="ic_write_data" fw_default="0x00"/>
        <node id="EXECUTE_WRITE" address="0x3" permission="w"
              description="writing any value here will execute a GBTx register write operation"
              fw_write_pulse_signal="ic_write_req" fw_write_done_signal="ic_write_done"/>
        <node id="EXECUTE_READ" address="0x4" permission="w"
              description="writing any value here will execute a GBTx register read operation"
              fw_write_pulse_signal="ic_read_req"/>
        <node id="GBTX_I2C_ADDR" address="0x5" mask="0x0000007f" permission="rw"
              description="GBTx I2C address as defined by the I2CADDRESS pins of the GBTx chip"
              fw_signal="ic_gbtx_i2c_addr" fw_default="0b0000001"/>
        <node id="GBTX_LINK_SELECT" address="0x6" mask="0x0000003f" permission="rw"
              description="Selects the GBT link to use"
              fw_signal="ic_link_select" fw_default="0b000000"/>
      </node>

      <node id="VFAT3" address="0x4000">
        <node id="CRC_ERROR_CNT" address="0x0" mask="0x0000ffff" permission="r"
              description="Number of CRC errors in the VFAT3 slow control reply packets"
              fw_signal="vfat3_sc_status_i.crc_error_cnt"/>
        <node id="PACKET_ERROR_CNT" address="0x0" mask="0xffff0000" permission="r"
              description="Number of packet errors in the VFAT3 slow control reply packets. Packet error means that either a received packet was too long, or a packet with good CRC was received but the contents were not as expected, more specifically one or more of the following fields were not correct: transaction ID, HDLC address, HDLC control, IPBus version, IPBus write flag."
              fw_signal="vfat3_sc_status_i.packet_error_cnt"/>
        <node id="BITSTUFFING_ERROR_CNT" address="0x1" mask="0x0000ffff" permission="r"
              description="Number of bitstuffing errors in the VFAT3 slow control reply packets. Bitstuffing error means that more than 5 SC1 characters were received in a row and it was not a frame separator (frame separator is 01111110)."
              fw_signal="vfat3_sc_status_i.bitstuff_error_cnt"/>
        <node id="TIMEOUT_ERROR_CNT" address="0x1" mask="0xffff0000" permission="r"
              description="Number of timeouts while waiting for a slow control reply from a VFAT3."
              fw_signal="vfat3_sc_status_i.timeout_error_cnt"/>
        <node id="AXI_STROBE_ERROR_CNT" address="0x2" mask="0x0000ffff" permission="r"
              description="Number of AXI strobe errors in VFAT3 slow control transactions. An AXI strobe error means that the AXI strobe went away before the VFAT3 slow control state machine replied or timed out. This might be caused by force closing the AXI transaction upstream e.g. a safety timeout in Zynq AXI master."
              fw_signal="vfat3_sc_status_i.axi_strobe_error_cnt"/>
        <node id="TRANSACTION_CNT" address="0x2" mask="0xffff0000" permission="r"
              description="Total number of VFAT3 transactions done so far. This counter rolls over."
              fw_signal="vfat3_sc_status_i.transaction_cnt"/>
      </node>

    </node>

    <!--OptoHybrid module -->
    <node id="OH"  address="0x00400000"
          description="Optohybrid Registers"
          fw_is_module="true"
          fw_is_module_external="true">



      <node id="OH${OH_IDX}"  address="0x0"
            description="Optohybrid ${OH_IDX}"
            generate="true" generate_size="2" generate_address_step="0x00010000" generate_idx_var="OH_IDX">

<node id="FPGA">
    <!--Control module -->
    <node id="CONTROL"  address="0x0000"
        description="Implements various control and monitoring functions of the Optohybrid"
        fw_is_module="true"
        fw_module_file="../src/control/control.vhd"
        fw_user_clock_signal="clock_i"
        fw_bus_clock_signal="clock_i"
        fw_bus_reset_signal="reset"
        fw_master_bus_signal="ipb_mosi_i"
        fw_slave_bus_signal="ipb_miso_o"
        fw_reg_addr_msb="5"
        fw_reg_addr_lsb="0">

        <node id="LOOPBACK" address="0x0" description="Loopback data register for testing read/write communication with the Optohybrid FPGA">
            description="Loopback Test Register" fw_signal="loopback">
            <node id="DATA" address="0x0" permission="rw"
                description="Write/Read Data Port"
                fw_signal="loopback"
                fw_default="0x01234567"/>
        </node> <!--Loopback-->

        <node id="RELEASE" address="0x1"
            description="Optohybrid Firmware Release Date and Version">
            <node id="DATE" address="0x0" permission="r"
                mask="0xffffffff"
                description="Release YYYY/MM/DD"
                fw_signal="(RELEASE_YEAR &amp; RELEASE_MONTH &amp; RELEASE_DAY)"/>
            <node id="VERSION" address="0x1" description="Optohybrid Release Version (XX.YY.ZZ.AA)
                \\ XX indicates the firmware major version
                \\ YY indicates the firmware minor version
                \\ ZZ indicates the firmware patch
                \\ AA indicates the hardware generation (0C = GE1/1 v3C short, 1C = GE1/1 v3C long, 2A = GE2/1 v1)
                ">
                <node id="MAJOR" address="0x0" permission="r"
                    mask="0xff"
                    description="Release semantic version major"
                    fw_signal="(MAJOR_VERSION)"/>
                <node id="MINOR" address="0x0" permission="r"
                    mask="0xff00"
                    description="Release semantic version minor"
                    fw_signal="(MINOR_VERSION)"/>
                <node id="BUILD" address="0x0" permission="r"
                    mask="0xff0000"
                    description="Release semantic version build"
                    fw_signal="(RELEASE_VERSION)"/>
                <node id="GENERATION" address="0x0" permission="r"
                    mask="0xff000000"
                    description="Release semantic version build"
                    fw_signal="(RELEASE_HARDWARE)"/>
            </node> <!--Version-->
        </node> <!--Release-->

        <node id="SEM" address="0x3" description = "Connects to Outputs of the FPGA's built-in single event upset monitoring system">
            <node id="CNT_SEM_CRITICAL" address="0x0" permission="r"
                mask="0x0000ffff"
                description="Counts of critical single event upsets"
                fw_cnt_en_signal="sem_critical"
                fw_cnt_snap_signal="cnt_snap"
                fw_signal="cnt_sem_critical"/>
            <node id="CNT_SEM_CORRECTION" address="0x1" permission="r"
                mask="0xffff0000"
                description="Counts of corrected single event upsets"
                fw_cnt_en_signal="sem_correction"
                fw_cnt_snap_signal="cnt_snap"
                fw_signal="cnt_sem_correction"/>
        </node> <!--SEM-->

        <node id="VFAT" address="0x5" description = "Controls the 12 VFAT reset outputs from the FPGA">
            <node id="RESET" address="0x0" permission="rw"
                mask="0x00000fff"
                description="Mask of VFAT Reset Outputs; 1=reset 0=enable"
                fw_signal="vfat_reset(11 downto 0)"
                fw_default="0x0"/>
        </node> <!--VFAT-->

        <node id="FMM" address="0x6" description = "FMM Run Control Module">
            <node id="DONT_WAIT" address="0x0" permission="rw"
                mask="0x00000001"
                description="OH won't wait for bc0 to start sending trigger"
                fw_signal="fmm_dont_wait"
                fw_default="0x1"/>
            <node id="STOP_TRIGGER" address="0x1" permission="r"
                mask="0x00000002"
                description="OH trigger is stopped waiting for bc0"
                fw_signal="fmm_trig_stop"/>
        </node> <!--FMM-->

        <node id="TTC" address="0x8" description = "TTC Status and Control">
            <node id="BX0_CNT_LOCAL" address="0x0" permission="r"
                mask="0x00ffffff"
                description="TTC BX0 Local Counter"
                fw_cnt_en_signal="bx0_local"
                fw_cnt_reset_signal="cnt_reset"
                fw_cnt_snap_signal="cnt_snap"
                fw_signal="cnt_bx0_lcl"/>
            <node id="BX0_CNT_TTC" address="0x1" permission="r"
                mask="0x00ffffff"
                description="TTC BX0 Received Counter"
                fw_cnt_en_signal="ttc_bc0"
                fw_cnt_reset_signal="cnt_reset"
                fw_cnt_snap_signal="cnt_snap"
                fw_signal="cnt_bx0_rxd"/>
            <node id="BXN_CNT_LOCAL" address="0x2" permission="r"
                description="TTC BXN Counter"
                mask="0xfff"
                fw_signal="ttc_bxn_counter"/>
            <node id="BXN_SYNC_ERR" address="0x3" permission="r"
                mask="0x1000"
                description="BXN Synchronization Error; Local BXN and received BXN do not match"
                fw_signal="ttc_bxn_sync_err"/>
            <node id="BX0_SYNC_ERR" address="0x4" permission="r"
                mask="0x2000"
                description="BX0 Synchronization Error"
                fw_signal="ttc_bx0_sync_err"/>
            <node id="BXN_OFFSET" address="0x5" permission="rw"
                mask="0xfff0000"
                description="Local BXN counter offset (starting value at resync)"
                fw_signal="ttc_bxn_offset"
                fw_default="0x0"/>
            <node id="L1A_CNT" address="0x6" permission="r"
                mask="0xffffff"
                description="L1A Received Counter"
                fw_cnt_en_signal="ttc_l1a"
                fw_cnt_reset_signal="cnt_reset"
                fw_cnt_snap_signal="cnt_snap"
                fw_signal="cnt_l1a"/>
            <node id="BXN_SYNC_ERR_CNT" address="0x7" permission="r"
                mask="0x0000ffff"
                description="BXN Sync Error Counter"
                fw_cnt_en_signal="ttc_bxn_sync_err"
                fw_cnt_reset_signal="cnt_reset"
                fw_cnt_snap_signal="cnt_snap"
                fw_signal="cnt_bxn_sync_err"/>
            <node id="BX0_SYNC_ERR_CNT" address="0x8" permission="r"
                mask="0xffff0000"
                description="BX0 Sync Error Counter"
                fw_cnt_en_signal="ttc_bx0_sync_err"
                fw_cnt_reset_signal="cnt_reset"
                fw_cnt_snap_signal="cnt_snap"
                fw_signal="cnt_bx0_sync_err"/>
        </node> <!--TTC-->


        <node id="SBITS" address="0x11" description = "S-bit and Cluster Packing Rate">
            <node id="CLUSTER_RATE" address="0x0" permission="r"
                description="Trigger cluster rate measured in Hz"
                fw_signal="cluster_rate"/>
        </node> <!--SBITS-->

        <node id="HDMI" address="0x12" description = "HDMI Connector Control:
                \\ Mode=0: Each signal is a single VFAT. The VFAT of interest is chosen by SBIT_SEL
                \\ Mode=1: Each signal is the OR of three VFATs in an ieta row. The row of interest is configured by SBIT_SEL
                \\ Mode=2: Each signal is the OR of four VFATs in an iphi half column (e.g. 0-3, 4-7, 8-11, 12-15, 16-19, 20-23)">
            <node id="SBIT_SEL0" address="0x0" permission="rw"
                description="HDMI Output 0 S-bit select"
                mask="0x1f"
                fw_signal="sbit_sel0"
                fw_default="0x0"/>

            <node id="SBIT_SEL1" address="0x0" permission="rw"
                description="HDMI Output 1 S-bit select"
                mask="0x3e0"
                fw_signal="sbit_sel1"
                fw_default="0x0"/>

            <node id="SBIT_SEL2" address="0x0" permission="rw"
                description="HDMI Output 2 S-bit select"
                mask="0x7c00"
                fw_signal="sbit_sel2"
                fw_default="0x0"/>

            <node id="SBIT_SEL3" address="0x0" permission="rw"
                description="HDMI Output 3 S-bit select"
                mask="0xf8000"
                fw_signal="sbit_sel3"
                fw_default="0x0"/>

            <node id="SBIT_SEL4" address="0x0" permission="rw"
                description="HDMI Output 4 S-bit select"
                mask="0x1f00000"
                fw_signal="sbit_sel4"
                fw_default="0x0"/>

            <node id="SBIT_SEL5" address="0x0" permission="rw"
                description="HDMI Output 5 S-bit select"
                mask="0x3e000000"
                fw_signal="sbit_sel5"
                fw_default="0x0"/>

            <node id="SBIT_SEL6" address="0x1" permission="rw"
                description="HDMI Output 6 S-bit select"
                mask="0x1f"
                fw_signal="sbit_sel6"
                fw_default="0x0"/>

            <node id="SBIT_SEL7" address="0x1" permission="rw"
                description="HDMI Output 7 S-bit select"
                mask="0x3e0"
                fw_signal="sbit_sel7"
                fw_default="0x0"/>

            <node id="SBIT_MODE0" address="0x1" permission="rw"
                description="HDMI Output 0 S-bit mode"
                mask="0xc00"
                fw_signal="sbit_mode0"
                fw_default="0x0"/>

            <node id="SBIT_MODE1" address="0x1" permission="rw"
                description="HDMI Output 1 S-bit mode"
                mask="0x3000"
                fw_signal="sbit_mode1"
                fw_default="0x0"/>

            <node id="SBIT_MODE2" address="0x1" permission="rw"
                description="HDMI Output 2 S-bit mode"
                mask="0xc000"
                fw_signal="sbit_mode2"
                fw_default="0x0"/>

            <node id="SBIT_MODE3" address="0x1" permission="rw"
                description="HDMI Output 3 S-bit mode"
                mask="0x30000"
                fw_signal="sbit_mode3"
                fw_default="0x0"/>

            <node id="SBIT_MODE4" address="0x1" permission="rw"
                description="HDMI Output 4 S-bit mode"
                mask="0xc0000"
                fw_signal="sbit_mode4"
                fw_default="0x0"/>

            <node id="SBIT_MODE5" address="0x1" permission="rw"
                description="HDMI Output 5 S-bit mode"
                mask="0x300000"
                fw_signal="sbit_mode5"
                fw_default="0x0"/>

            <node id="SBIT_MODE6" address="0x1" permission="rw"
                description="HDMI Output 6 S-bit mode"
                mask="0xc00000"
                fw_signal="sbit_mode6"
                fw_default="0x0"/>

            <node id="SBIT_MODE7" address="0x1" permission="rw"
                description="HDMI Output 7 S-bit mode"
                mask="0x3000000"
                fw_signal="sbit_mode7"
                fw_default="0x0"/>
        </node> <!--HDMI-->

        <node id="CNT_SNAP" address="0x14" description = "Control the global counter snapshot">
            <node id="PULSE" address="0x0" permission="w"
                description="Pulse to take a counter snapshot"
                mask="0x1"
                fw_write_pulse_signal="cnt_snap_pulse"/>
            <node id="DISABLE" address="0x1" permission="rw"
                description="0=enable snapshots (counters freeze synchronously and need a snapshot to update)"
                mask="0x2"
                fw_default="1"
                fw_signal="cnt_snap_disable"/>
        </node> <!--CNT_SNAP-->

        <node id="SOFT_RESET" address="0x16" permission="w"
                description = "Write to set the soft logic reset of the Optohybrid FPGA"
                mask="0x1"
                fw_write_pulse_signal="soft_reset_o">
        </node> <!--Soft Reset-->

        <node id="DNA" address="0x17" description = "57 Bit FPGA-specific device identifier">
            <node id="DNA_LSBS" address="0x0" permission="r"
                description = "Device DNA bits 31 downto 0"
                mask="0xffffffff"
                fw_signal="dna(31 downto 0)"/>
            <node id="DNA_MSBS" address="0x1" permission="r"
                description = "Device DNA bits 56 downto 32"
                mask="0x01ffffff"
                fw_signal="dna(56 downto 32)"/>
        </node> <!--DNA-->
    </node> <!--CTRL-->

    <!--ADC module -->
    <node id="ADC"  address="0x1000"
        description="Connects to the Virtex-6 XADC and allows for reading of temperature, VCCINT, and VCCAUX voltages"
        fw_is_module="true"
        fw_module_file="../src/control/adc.vhd"
        fw_user_clock_signal="clock_i"
        fw_bus_clock_signal="ipb_clk_i"
        fw_bus_reset_signal="ipb_reset_i"
        fw_master_bus_signal="ipb_mosi_i"
        fw_slave_bus_signal="ipb_miso_o"
        fw_reg_addr_msb="3"
        fw_reg_addr_lsb="0">

            <node id="CTRL" address="0x0">

                <node id="OVERTEMP" address="0x0" permission="r"
                    mask="0x00000001"
                    description="FPGA over temperature"
                    fw_signal="overtemp"/>
                <node id="VCCAUX_ALARM" address="0x0" permission="r"
                    mask="0x00000002"
                    description="FPGA VCCAUX Alarm"
                    fw_signal="vccaux_alarm"/>
                <node id="VCCINT_ALARM" address="0x0" permission="r"
                    mask="0x00000004"
                    description="FPGA VCCINT Alarm"
                    fw_signal="vccint_alarm"/>

                <node id="ADR_IN" address="0x0" permission="rw"
                    description="XADC Addr In"
                    fw_default="0x0"
                    mask="0x3f8"
                    fw_signal="daddr"/>

                <node id="ENABLE" address="0x0" permission="rw"
                    description="XADC Data In"
                    mask="0x400"
                    fw_default="0x1"
                    fw_signal="den"/>

                <node id="DATA_IN" address="0x1" permission="rw"
                    description="XADC Data In"
                    mask="0x0000ffff"
                    fw_default="0x0"
                    fw_signal="data_in"/>

                <node id="DATA_OUT" address="0x1" permission="r"
                    description="XADC Data Out"
                    mask="0xffff0000"
                    fw_read_ready_signal="data_ready"
                    fw_signal="data_out"/>

                <node id="RESET" address="0x2" permission="w"
                    mask="0x00000001"
                    description="XADC Reset"
                    fw_write_pulse_signal="reset_local"/>

                <node id="WR_EN" address="0x3" permission="w"
                    mask="0x00000001"
                    description="XADC Write Enable"
                    fw_write_pulse_signal="write_en"/>

                <node id="CNT_OVERTEMP" address="0x0" permission="r"
                    mask="0x3f800"
                    description="Overtemperature counter"
                    fw_cnt_en_signal="overtemp"
                    fw_cnt_reset_signal="reset"
                    fw_cnt_snap_signal="cnt_snap"
                    fw_signal="cnt_overtemp"/>

                <node id="CNT_VCCAUX_ALARM" address="0x0" permission="r"
                    description="VCCAUX Alarm Counter"
                    mask="0x1fc0000"
                    fw_cnt_en_signal="vccaux_alarm"
                    fw_cnt_reset_signal="reset"
                    fw_cnt_snap_signal="cnt_snap"
                    fw_signal="cnt_vccaux_alarm"/>

                <node id="CNT_VCCINT_ALARM" address="0x0" permission="r"
                    mask="0xfe000000"
                    description="VCCINT Alarm Counter"
                    fw_cnt_en_signal="vccint_alarm"
                    fw_cnt_reset_signal="reset"
                    fw_cnt_snap_signal="cnt_snap"
                    fw_signal="cnt_vccint_alarm"/>
            </node> <!--CTRL-->
    </node> <!--ADC-->

    <!--Trigger Module -->
    <node id="TRIG"  address="0x2000"
        description="Connects to the trigger control module"
        fw_is_module="true"
        fw_module_file="../src/trigger/trigger.vhd"
        fw_user_clock_signal="clk_40"
        fw_bus_clock_signal="clk_40"
        fw_bus_reset_signal="ipb_reset"
        fw_master_bus_signal="ipb_mosi_i"
        fw_slave_bus_signal="ipb_miso_o"
        fw_reg_addr_msb="7"
        fw_reg_addr_lsb="0">

        <node id="CTRL" address="0x0" description = "Controls and monitors various parameters of the S-bit deserialization and cluster building.">

            <node id="VFAT_MASK" address="0x0" permission="rw"
                description="12 bit mask of VFATs (1=off)"
                mask="0xfff"
                fw_signal="vfat_mask"
                fw_default="0x0"/>

            <node id="SBIT_DEADTIME" address="0x0" permission="rw"
                description="Set programmable oneshot deadtime which applies to retriggers on individual VFAT channels"
                fw_signal="trig_deadtime"
                mask="0x0f000000"
                fw_default="0x7"/>

            <node id="ACTIVE_VFATS" address="0x1" permission="r"
                description="12 bit list of VFATs with hits in this BX"
                mask="0xfff"
                fw_signal="active_vfats"/>

            <node id="CNT_OVERFLOW" address="0x2" permission="r"
                mask="0xffff"
                description="Overflow Counter (more than 8 clusters in a bx)"
                fw_cnt_en_signal="sbit_overflow"
                fw_cnt_reset_signal="cnt_reset"
                fw_cnt_snap_signal="cnt_snap"
                fw_signal="cnt_sbit_overflow"/>

            <node id="ALIGNED_COUNT_TO_READY" address="0x2" permission="rw"
                description="Number of link consecutive good frames required before the transmission unit is marked as good and S-bits can be produced"
                fw_signal="aligned_count_to_ready"
                mask="0xfff0000"
                fw_default="0x1ff"/>

            <node id="SBIT_SOT_READY" address="0x3" permission="r"
                description="12 bit list of VFATs with stable Start-of-frame pulses (in sync for a number of clock cycles)"
                mask="0xfff"
                fw_signal="sot_is_aligned"/>
            <node id="SBIT_SOT_UNSTABLE" address="0x4" permission="r"
                description="12 bit list of VFATs with unstable Start-of-frame pulses (became misaligned after already achieving lock)"
                mask="0xfff"
                fw_signal="sot_unstable" />
            <node id="SBIT_SOT_INVALID_BITSKIP" address="0xe2" permission="r"
                description="12 bit list of VFATs with a invalid bitskip counter for Start-of-frame pulses"
                mask="0xfff"
                fw_signal="sot_invalid_bitskip" />

	    <node id="INVERT" address="0x5" description="Controls the polarity of S-bit signals to account for polarity swaps on the GEB or OH">
                <!-- START: INVERT_REGS DO NOT EDIT -->
                <node id="SOT_INVERT" address="0x0" permission="rw"
                    description="1=invert pair"
                    fw_signal="sot_invert"
                    mask="0x00000fff"
                    fw_default="0x000802"/>
                <node id="VFAT0_TU_INVERT" address="0x1" permission="rw"
                    description="1=invert pair"
                    fw_signal="TU_INVERT (7 downto 0)"
                    mask="0x000000FF"
                    fw_default="0xFF"/>
                <node id="VFAT1_TU_INVERT" address="0x1" permission="rw"
                    description="1=invert pair"
                    fw_signal="TU_INVERT (15 downto 8)"
                    mask="0x0000FF00"
                    fw_default="0x01"/>
                <node id="VFAT2_TU_INVERT" address="0x1" permission="rw"
                    description="1=invert pair"
                    fw_signal="TU_INVERT (23 downto 16)"
                    mask="0x00FF0000"
                    fw_default="0x00"/>
                <node id="VFAT3_TU_INVERT" address="0x1" permission="rw"
                    description="1=invert pair"
                    fw_signal="TU_INVERT (31 downto 24)"
                    mask="0xFF000000"
                    fw_default="0x00"/>
                <node id="VFAT4_TU_INVERT" address="0x2" permission="rw"
                    description="1=invert pair"
                    fw_signal="TU_INVERT (39 downto 32)"
                    mask="0x000000FF"
                    fw_default="0x00"/>
                <node id="VFAT5_TU_INVERT" address="0x2" permission="rw"
                    description="1=invert pair"
                    fw_signal="TU_INVERT (47 downto 40)"
                    mask="0x0000FF00"
                    fw_default="0x00"/>
                <node id="VFAT6_TU_INVERT" address="0x2" permission="rw"
                    description="1=invert pair"
                    fw_signal="TU_INVERT (55 downto 48)"
                    mask="0x00FF0000"
                    fw_default="0x00"/>
                <node id="VFAT7_TU_INVERT" address="0x2" permission="rw"
                    description="1=invert pair"
                    fw_signal="TU_INVERT (63 downto 56)"
                    mask="0xFF000000"
                    fw_default="0xEC"/>
                <node id="VFAT8_TU_INVERT" address="0x3" permission="rw"
                    description="1=invert pair"
                    fw_signal="TU_INVERT (71 downto 64)"
                    mask="0x000000FF"
                    fw_default="0x20"/>
                <node id="VFAT9_TU_INVERT" address="0x3" permission="rw"
                    description="1=invert pair"
                    fw_signal="TU_INVERT (79 downto 72)"
                    mask="0x0000FF00"
                    fw_default="0xDE"/>
                <node id="VFAT10_TU_INVERT" address="0x3" permission="rw"
                    description="1=invert pair"
                    fw_signal="TU_INVERT (87 downto 80)"
                    mask="0x00FF0000"
                    fw_default="0x7F"/>
                <node id="VFAT11_TU_INVERT" address="0x3" permission="rw"
                    description="1=invert pair"
                    fw_signal="TU_INVERT (95 downto 88)"
                    mask="0xFF000000"
                    fw_default="0xDD"/>
                    <!-- END: INVERT_REGS DO NOT EDIT -->
                </node> <!--INVERT-->

                <node id="SBITS_MUX" address="0xe" description="Multiplexed copy of Sbits from a selected VFAT">

                    <node id="SBIT_MUX_SEL" address="0x0" permission="rw"
                        description="Select a VFAT which will connect to the S-bit multiplexer"
                        fw_signal="sbits_mux_sel"
                        mask="0x1f0"
                        fw_default="0x10"/>

                    <node id="SBITS_MUX_LSB" address="0x1" permission="r"
                        description="Multiplexed S-bits 31 to 0"
                        fw_signal="sbits_mux(31 downto 0)"
                        mask="0xffffffff"/>

                    <node id="SBITS_MUX_MSB" address="0x2" permission="r"
                        description="Multiplexed S-bits 63 to 32"
                        fw_signal="sbits_mux(63 downto 32)"
                        mask="0xffffffff"/>

                </node> <!--SBITS_MUX-->

                <node id="TU_MASK" address="0x11" description = "VFAT Trigger Unit Mask \\ Set a pair to 1 to invert it">

                <!-- START: TU_MASK DO NOT EDIT -->
                <node id="VFAT0_TU_MASK" address="0x0" permission="rw"
                    description="1 = mask the differential pair"
                    fw_signal="TU_MASK (7 downto 0)"
                    mask="0x000000FF"
                    fw_default="0x0"/>
                <node id="VFAT1_TU_MASK" address="0x0" permission="rw"
                    description="1 = mask the differential pair"
                    fw_signal="TU_MASK (15 downto 8)"
                    mask="0x0000FF00"
                    fw_default="0x0"/>
                <node id="VFAT2_TU_MASK" address="0x0" permission="rw"
                    description="1 = mask the differential pair"
                    fw_signal="TU_MASK (23 downto 16)"
                    mask="0x00FF0000"
                    fw_default="0x0"/>
                <node id="VFAT3_TU_MASK" address="0x0" permission="rw"
                    description="1 = mask the differential pair"
                    fw_signal="TU_MASK (31 downto 24)"
                    mask="0xFF000000"
                    fw_default="0x0"/>
                <node id="VFAT4_TU_MASK" address="0x1" permission="rw"
                    description="1 = mask the differential pair"
                    fw_signal="TU_MASK (39 downto 32)"
                    mask="0x000000FF"
                    fw_default="0x0"/>
                <node id="VFAT5_TU_MASK" address="0x1" permission="rw"
                    description="1 = mask the differential pair"
                    fw_signal="TU_MASK (47 downto 40)"
                    mask="0x0000FF00"
                    fw_default="0x0"/>
                <node id="VFAT6_TU_MASK" address="0x1" permission="rw"
                    description="1 = mask the differential pair"
                    fw_signal="TU_MASK (55 downto 48)"
                    mask="0x00FF0000"
                    fw_default="0x0"/>
                <node id="VFAT7_TU_MASK" address="0x1" permission="rw"
                    description="1 = mask the differential pair"
                    fw_signal="TU_MASK (63 downto 56)"
                    mask="0xFF000000"
                    fw_default="0x0"/>
                <node id="VFAT8_TU_MASK" address="0x2" permission="rw"
                    description="1 = mask the differential pair"
                    fw_signal="TU_MASK (71 downto 64)"
                    mask="0x000000FF"
                    fw_default="0x0"/>
                <node id="VFAT9_TU_MASK" address="0x2" permission="rw"
                    description="1 = mask the differential pair"
                    fw_signal="TU_MASK (79 downto 72)"
                    mask="0x0000FF00"
                    fw_default="0x0"/>
                <node id="VFAT10_TU_MASK" address="0x2" permission="rw"
                    description="1 = mask the differential pair"
                    fw_signal="TU_MASK (87 downto 80)"
                    mask="0x00FF0000"
                    fw_default="0x0"/>
                <node id="VFAT11_TU_MASK" address="0x2" permission="rw"
                    description="1 = mask the differential pair"
                    fw_signal="TU_MASK (95 downto 88)"
                    mask="0xFF000000"
                    fw_default="0x0"/>
                <!-- END: TU_MASK DO NOT EDIT -->
                </node> <!--TU_MASK-->
            </node> <!--CTRL-->

            <node id="CNT" address="0x17" description = "S-BIT Counters \\  Set CNT_PERSIST to 1 to accumulate. Otherwise the counters will automatically reset after a programmable time (default is 1 second). By default this time is 1 second, making these counters a rate counter in Hertz">

            <node id="VFAT${VFAT_CNT_IDX}_SBITS" address="0x0" permission="r"
                mask="0xffffffff"
                description="VFAT ${VFAT_CNT_IDX} Counter"
                fw_cnt_en_signal="active_vfats(${VFAT_CNT_IDX})"
                fw_cnt_snap_signal="sbit_cnt_snap"
                fw_cnt_reset_signal="cnt_reset_strobed"
                fw_cnt_clk_signal="clk_40_sbit"
                fw_signal="cnt_vfat${VFAT_CNT_IDX}"
                generate="true"
                generate_size="12"
                generate_address_step="0x1"
                generate_idx_var="VFAT_CNT_IDX"/>

                <node id="RESET" address="0x18" permission="w"
                    mask="0x1"
                    description="Reset S-bit counters"
                    fw_write_pulse_signal="reset_counters"/>

                <node id="SBIT_CNT_PERSIST" address="0x19" permission="rw"
                    mask="0x1"
                    description="1=counters will persist until manually reset; \n
                                0=counters will automatically reset at CNT_TIME"
                    fw_signal="sbit_cnt_persist"
                    fw_default="0"/>

                <node id="SBIT_CNT_TIME_MAX" address="0x1a" permission="rw"
                    mask="0xffffffff"
                    description="Number of BX that the VFAT S-bit counters will count to before automatically resetting to zero"
                    fw_signal="sbit_cnt_time_max"
                    fw_default="0x2638e98"/>

                <node id="CLUSTER_COUNT" address="0x1b" permission="r"
                    mask="0xffffffff"
                    description="VFAT Cluster Counter (chamber)"
                    fw_cnt_en_signal="valid_clusters_or"
                    fw_cnt_snap_signal="sbit_cnt_snap"
                    fw_cnt_reset_signal="cnt_reset_strobed"
                    fw_signal="cnt_clusters"/>

                <node id="SBITS_OVER_64x${OVERFLOW_IDX}" address="0x1f" permission="r"
                    mask="0x0000ffff"
                    description="More than 64 * ${OVERFLOW_IDX} Sbits in a bx Counter"
                    fw_cnt_en_signal="sbits_comparator_over_threshold(${OVERFLOW_IDX})"
                    fw_cnt_snap_signal="sbit_cnt_snap"
                    fw_cnt_reset_signal="cnt_reset_strobed"
                    fw_cnt_clk_signal="clk_40_sbit"
                    fw_signal="cnt_over_threshold${OVERFLOW_IDX}"
                    generate="true"
                    generate_size="12"
                    generate_address_step="0x1"
                    generate_idx_var="OVERFLOW_IDX"/>

            </node> <!--CNT-->

            <node id="TIMING" address="0x53"
                description = "Controls the tap delay settings of the S-bit trigger unit inputs.
                Phase shifts the inputs in 78 ps increments
                \\ The delay of each S-bit in a VFAT should be increased to match the longest delay incurred by the GEB + Optohybrid routing on that VFAT">

                <!-- START: TIMING_DELAYS DO NOT EDIT -->
                    <node id="TAP_DELAY_VFAT0_BIT0" address="0x0" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 0 S-bit 0 tap delay"
                        fw_signal="trig_tap_delay(0)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT0_BIT1" address="0x0" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 0 S-bit 1 tap delay"
                        fw_signal="trig_tap_delay(1)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT0_BIT2" address="0x0" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 0 S-bit 2 tap delay"
                        fw_signal="trig_tap_delay(2)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT0_BIT3" address="0x0" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 0 S-bit 3 tap delay"
                        fw_signal="trig_tap_delay(3)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT0_BIT4" address="0x0" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 0 S-bit 4 tap delay"
                        fw_signal="trig_tap_delay(4)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT0_BIT5" address="0x0" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 0 S-bit 5 tap delay"
                        fw_signal="trig_tap_delay(5)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT0_BIT6" address="0x1" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 0 S-bit 6 tap delay"
                        fw_signal="trig_tap_delay(6)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT0_BIT7" address="0x1" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 0 S-bit 7 tap delay"
                        fw_signal="trig_tap_delay(7)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT1_BIT0" address="0x1" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 1 S-bit 0 tap delay"
                        fw_signal="trig_tap_delay(8)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT1_BIT1" address="0x1" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 1 S-bit 1 tap delay"
                        fw_signal="trig_tap_delay(9)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT1_BIT2" address="0x1" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 1 S-bit 2 tap delay"
                        fw_signal="trig_tap_delay(10)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT1_BIT3" address="0x1" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 1 S-bit 3 tap delay"
                        fw_signal="trig_tap_delay(11)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT1_BIT4" address="0x2" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 1 S-bit 4 tap delay"
                        fw_signal="trig_tap_delay(12)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT1_BIT5" address="0x2" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 1 S-bit 5 tap delay"
                        fw_signal="trig_tap_delay(13)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT1_BIT6" address="0x2" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 1 S-bit 6 tap delay"
                        fw_signal="trig_tap_delay(14)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT1_BIT7" address="0x2" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 1 S-bit 7 tap delay"
                        fw_signal="trig_tap_delay(15)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT2_BIT0" address="0x2" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 2 S-bit 0 tap delay"
                        fw_signal="trig_tap_delay(16)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT2_BIT1" address="0x2" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 2 S-bit 1 tap delay"
                        fw_signal="trig_tap_delay(17)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT2_BIT2" address="0x3" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 2 S-bit 2 tap delay"
                        fw_signal="trig_tap_delay(18)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT2_BIT3" address="0x3" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 2 S-bit 3 tap delay"
                        fw_signal="trig_tap_delay(19)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT2_BIT4" address="0x3" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 2 S-bit 4 tap delay"
                        fw_signal="trig_tap_delay(20)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT2_BIT5" address="0x3" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 2 S-bit 5 tap delay"
                        fw_signal="trig_tap_delay(21)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT2_BIT6" address="0x3" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 2 S-bit 6 tap delay"
                        fw_signal="trig_tap_delay(22)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT2_BIT7" address="0x3" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 2 S-bit 7 tap delay"
                        fw_signal="trig_tap_delay(23)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT3_BIT0" address="0x4" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 3 S-bit 0 tap delay"
                        fw_signal="trig_tap_delay(24)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT3_BIT1" address="0x4" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 3 S-bit 1 tap delay"
                        fw_signal="trig_tap_delay(25)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT3_BIT2" address="0x4" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 3 S-bit 2 tap delay"
                        fw_signal="trig_tap_delay(26)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT3_BIT3" address="0x4" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 3 S-bit 3 tap delay"
                        fw_signal="trig_tap_delay(27)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT3_BIT4" address="0x4" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 3 S-bit 4 tap delay"
                        fw_signal="trig_tap_delay(28)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT3_BIT5" address="0x4" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 3 S-bit 5 tap delay"
                        fw_signal="trig_tap_delay(29)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT3_BIT6" address="0x5" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 3 S-bit 6 tap delay"
                        fw_signal="trig_tap_delay(30)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT3_BIT7" address="0x5" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 3 S-bit 7 tap delay"
                        fw_signal="trig_tap_delay(31)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT4_BIT0" address="0x5" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 4 S-bit 0 tap delay"
                        fw_signal="trig_tap_delay(32)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT4_BIT1" address="0x5" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 4 S-bit 1 tap delay"
                        fw_signal="trig_tap_delay(33)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT4_BIT2" address="0x5" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 4 S-bit 2 tap delay"
                        fw_signal="trig_tap_delay(34)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT4_BIT3" address="0x5" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 4 S-bit 3 tap delay"
                        fw_signal="trig_tap_delay(35)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT4_BIT4" address="0x6" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 4 S-bit 4 tap delay"
                        fw_signal="trig_tap_delay(36)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT4_BIT5" address="0x6" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 4 S-bit 5 tap delay"
                        fw_signal="trig_tap_delay(37)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT4_BIT6" address="0x6" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 4 S-bit 6 tap delay"
                        fw_signal="trig_tap_delay(38)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT4_BIT7" address="0x6" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 4 S-bit 7 tap delay"
                        fw_signal="trig_tap_delay(39)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT5_BIT0" address="0x6" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 5 S-bit 0 tap delay"
                        fw_signal="trig_tap_delay(40)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT5_BIT1" address="0x6" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 5 S-bit 1 tap delay"
                        fw_signal="trig_tap_delay(41)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT5_BIT2" address="0x7" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 5 S-bit 2 tap delay"
                        fw_signal="trig_tap_delay(42)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT5_BIT3" address="0x7" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 5 S-bit 3 tap delay"
                        fw_signal="trig_tap_delay(43)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT5_BIT4" address="0x7" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 5 S-bit 4 tap delay"
                        fw_signal="trig_tap_delay(44)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT5_BIT5" address="0x7" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 5 S-bit 5 tap delay"
                        fw_signal="trig_tap_delay(45)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT5_BIT6" address="0x7" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 5 S-bit 6 tap delay"
                        fw_signal="trig_tap_delay(46)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT5_BIT7" address="0x7" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 5 S-bit 7 tap delay"
                        fw_signal="trig_tap_delay(47)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT6_BIT0" address="0x8" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 6 S-bit 0 tap delay"
                        fw_signal="trig_tap_delay(48)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT6_BIT1" address="0x8" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 6 S-bit 1 tap delay"
                        fw_signal="trig_tap_delay(49)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT6_BIT2" address="0x8" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 6 S-bit 2 tap delay"
                        fw_signal="trig_tap_delay(50)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT6_BIT3" address="0x8" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 6 S-bit 3 tap delay"
                        fw_signal="trig_tap_delay(51)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT6_BIT4" address="0x8" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 6 S-bit 4 tap delay"
                        fw_signal="trig_tap_delay(52)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT6_BIT5" address="0x8" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 6 S-bit 5 tap delay"
                        fw_signal="trig_tap_delay(53)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT6_BIT6" address="0x9" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 6 S-bit 6 tap delay"
                        fw_signal="trig_tap_delay(54)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT6_BIT7" address="0x9" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 6 S-bit 7 tap delay"
                        fw_signal="trig_tap_delay(55)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT7_BIT0" address="0x9" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 7 S-bit 0 tap delay"
                        fw_signal="trig_tap_delay(56)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT7_BIT1" address="0x9" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 7 S-bit 1 tap delay"
                        fw_signal="trig_tap_delay(57)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT7_BIT2" address="0x9" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 7 S-bit 2 tap delay"
                        fw_signal="trig_tap_delay(58)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT7_BIT3" address="0x9" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 7 S-bit 3 tap delay"
                        fw_signal="trig_tap_delay(59)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT7_BIT4" address="0xA" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 7 S-bit 4 tap delay"
                        fw_signal="trig_tap_delay(60)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT7_BIT5" address="0xA" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 7 S-bit 5 tap delay"
                        fw_signal="trig_tap_delay(61)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT7_BIT6" address="0xA" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 7 S-bit 6 tap delay"
                        fw_signal="trig_tap_delay(62)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT7_BIT7" address="0xA" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 7 S-bit 7 tap delay"
                        fw_signal="trig_tap_delay(63)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT8_BIT0" address="0xA" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 8 S-bit 0 tap delay"
                        fw_signal="trig_tap_delay(64)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT8_BIT1" address="0xA" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 8 S-bit 1 tap delay"
                        fw_signal="trig_tap_delay(65)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT8_BIT2" address="0xB" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 8 S-bit 2 tap delay"
                        fw_signal="trig_tap_delay(66)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT8_BIT3" address="0xB" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 8 S-bit 3 tap delay"
                        fw_signal="trig_tap_delay(67)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT8_BIT4" address="0xB" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 8 S-bit 4 tap delay"
                        fw_signal="trig_tap_delay(68)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT8_BIT5" address="0xB" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 8 S-bit 5 tap delay"
                        fw_signal="trig_tap_delay(69)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT8_BIT6" address="0xB" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 8 S-bit 6 tap delay"
                        fw_signal="trig_tap_delay(70)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT8_BIT7" address="0xB" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 8 S-bit 7 tap delay"
                        fw_signal="trig_tap_delay(71)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT9_BIT0" address="0xC" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 9 S-bit 0 tap delay"
                        fw_signal="trig_tap_delay(72)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT9_BIT1" address="0xC" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 9 S-bit 1 tap delay"
                        fw_signal="trig_tap_delay(73)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT9_BIT2" address="0xC" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 9 S-bit 2 tap delay"
                        fw_signal="trig_tap_delay(74)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT9_BIT3" address="0xC" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 9 S-bit 3 tap delay"
                        fw_signal="trig_tap_delay(75)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT9_BIT4" address="0xC" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 9 S-bit 4 tap delay"
                        fw_signal="trig_tap_delay(76)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT9_BIT5" address="0xC" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 9 S-bit 5 tap delay"
                        fw_signal="trig_tap_delay(77)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT9_BIT6" address="0xD" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 9 S-bit 6 tap delay"
                        fw_signal="trig_tap_delay(78)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT9_BIT7" address="0xD" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 9 S-bit 7 tap delay"
                        fw_signal="trig_tap_delay(79)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT10_BIT0" address="0xD" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 10 S-bit 0 tap delay"
                        fw_signal="trig_tap_delay(80)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT10_BIT1" address="0xD" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 10 S-bit 1 tap delay"
                        fw_signal="trig_tap_delay(81)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT10_BIT2" address="0xD" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 10 S-bit 2 tap delay"
                        fw_signal="trig_tap_delay(82)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT10_BIT3" address="0xD" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 10 S-bit 3 tap delay"
                        fw_signal="trig_tap_delay(83)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT10_BIT4" address="0xE" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 10 S-bit 4 tap delay"
                        fw_signal="trig_tap_delay(84)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT10_BIT5" address="0xE" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 10 S-bit 5 tap delay"
                        fw_signal="trig_tap_delay(85)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT10_BIT6" address="0xE" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 10 S-bit 6 tap delay"
                        fw_signal="trig_tap_delay(86)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT10_BIT7" address="0xE" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 10 S-bit 7 tap delay"
                        fw_signal="trig_tap_delay(87)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT11_BIT0" address="0xE" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 11 S-bit 0 tap delay"
                        fw_signal="trig_tap_delay(88)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT11_BIT1" address="0xE" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 11 S-bit 1 tap delay"
                        fw_signal="trig_tap_delay(89)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT11_BIT2" address="0xF" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 11 S-bit 2 tap delay"
                        fw_signal="trig_tap_delay(90)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT11_BIT3" address="0xF" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 11 S-bit 3 tap delay"
                        fw_signal="trig_tap_delay(91)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT11_BIT4" address="0xF" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 11 S-bit 4 tap delay"
                        fw_signal="trig_tap_delay(92)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT11_BIT5" address="0xF" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 11 S-bit 5 tap delay"
                        fw_signal="trig_tap_delay(93)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT11_BIT6" address="0xF" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 11 S-bit 6 tap delay"
                        fw_signal="trig_tap_delay(94)"
                        fw_default="0"/>
                    <node id="TAP_DELAY_VFAT11_BIT7" address="0xF" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 11 S-bit 7 tap delay"
                        fw_signal="trig_tap_delay(95)"
                        fw_default="0"/>
                    <node id="SOT_TAP_DELAY_VFAT0" address="0x10" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 0 SOT tap delay"
                        fw_signal="sot_tap_delay(0)"
                        fw_default="0"/>
                    <node id="SOT_TAP_DELAY_VFAT1" address="0x10" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 1 SOT tap delay"
                        fw_signal="sot_tap_delay(1)"
                        fw_default="0"/>
                    <node id="SOT_TAP_DELAY_VFAT2" address="0x10" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 2 SOT tap delay"
                        fw_signal="sot_tap_delay(2)"
                        fw_default="0"/>
                    <node id="SOT_TAP_DELAY_VFAT3" address="0x10" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 3 SOT tap delay"
                        fw_signal="sot_tap_delay(3)"
                        fw_default="0"/>
                    <node id="SOT_TAP_DELAY_VFAT4" address="0x10" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 4 SOT tap delay"
                        fw_signal="sot_tap_delay(4)"
                        fw_default="0"/>
                    <node id="SOT_TAP_DELAY_VFAT5" address="0x10" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 5 SOT tap delay"
                        fw_signal="sot_tap_delay(5)"
                        fw_default="0"/>
                    <node id="SOT_TAP_DELAY_VFAT6" address="0x11" permission="rw"
                        mask="0x0000001F"
                        description="VFAT 6 SOT tap delay"
                        fw_signal="sot_tap_delay(6)"
                        fw_default="0"/>
                    <node id="SOT_TAP_DELAY_VFAT7" address="0x11" permission="rw"
                        mask="0x000003E0"
                        description="VFAT 7 SOT tap delay"
                        fw_signal="sot_tap_delay(7)"
                        fw_default="0"/>
                    <node id="SOT_TAP_DELAY_VFAT8" address="0x11" permission="rw"
                        mask="0x00007C00"
                        description="VFAT 8 SOT tap delay"
                        fw_signal="sot_tap_delay(8)"
                        fw_default="0"/>
                    <node id="SOT_TAP_DELAY_VFAT9" address="0x11" permission="rw"
                        mask="0x000F8000"
                        description="VFAT 9 SOT tap delay"
                        fw_signal="sot_tap_delay(9)"
                        fw_default="0"/>
                    <node id="SOT_TAP_DELAY_VFAT10" address="0x11" permission="rw"
                        mask="0x01F00000"
                        description="VFAT 10 SOT tap delay"
                        fw_signal="sot_tap_delay(10)"
                        fw_default="0"/>
                    <node id="SOT_TAP_DELAY_VFAT11" address="0x11" permission="rw"
                        mask="0x3E000000"
                        description="VFAT 11 SOT tap delay"
                        fw_signal="sot_tap_delay(11)"
                        fw_default="0"/>
                <!-- END: TIMING_DELAYS DO NOT EDIT -->
            </node> <!--Timing Delays-->

            <node id="LINKS" address="0x80" description = "Controls and monitors the multi-gigabit links that drive the trigger fiber tranceivers">

                <node id="RESET" address="0x0" permission="w"
                    mask="0x1"
                    description="Reset trigger links"
                    fw_write_pulse_signal="reset_links"/>
                <node id="TX_PLL_LOCKED" address="0x1" permission="r"
                    mask="0x00000001"
                    description="Transmit PLLs are Locked"
                    fw_signal="tx_pll_locked"/>
                <node id="TX_RESET_DONE" address="0x1" permission="r"
                    mask="0x00000010"
                    description="Transmit Resets are Done"
                    fw_signal="tx_reset_done"/>
                <node id="TX_PRBS_MODE" address="0x1" permission="rw"
                    mask="0x00000700"
                    description="000: Standard \n 001: PRBS-7 \n 010: PRBS-15 \n 011: PRBS-23 \n 100: PRBS-31"
                    fw_default="0x0"
                    fw_signal="tx_prbs_mode"/>
                <node id="TX_PLL_RESET" address="0x1" permission="rw"
                    mask="0x00000800"
                    description="This port resets the TX PLL of the GTX transceiver when driven High. It affects the clock generated from the TX PMA. When this reset is asserted or deasserted, TXRESET must also be asserted or deasserted."
                    fw_default="0x0"
                    fw_signal="pll_reset"/>
                <node id="MGT_RESET" address="0x1" permission="rw"
                    mask="0x0000f000"
                    description="Asserts the MGT reset (GTXTXRESET). This sequence takes about 120 us to complete and systematically resets all subcomponents of the GTX transceiver TX. "
                    fw_default="0x0"
                    fw_signal="mgt_reset"/>
                <node id="GTXTEST_START" address="0x1" permission="rw"
                    mask="0x00010000"
                    description="Initiates a double reset of the TX output clock dividers"
                    fw_default="0x0"
                    fw_signal="gtxtest_start"/>
                <node id="TXRESET" address="0x1" permission="rw"
                    mask="0x00020000"
                    description="PCS TX system reset. Resets the TX FIFO, 8B/10B encoder and other transmitter registers. This reset is a subset of GTXTXRESET."
                    fw_default="0x0"
                    fw_signal="txreset"/>
                <node id="MGT_REALIGN" address="0x1" permission="rw"
                    mask="0x00040000"
                    description="Resets the TX_SYNC module to realign the buf_bypass alignment FSM"
                    fw_default="0x0"
                    fw_signal="mgt_realign"/>
                <node id="TXPOWERDOWN" address="0x1" permission="rw"
                    mask="0x00080000"
                    fw_default="0x0"
                    description="Set the MGT tx into powerdown. The type of powerdown is controlled by TXPOWERDOWN_MODE"
                    fw_signal="txpowerdown"/>
                <node id="TXPOWERDOWN_MODE" address="0x1" permission="rw"
                    mask="0x00300000"
                    description="00: P0 (normal operation) \n 01: P0s (low recovery time power down) \n 10: P1 (longer recovery time \n Receiver Detection still on) \n 11: P2 (lowest power state)"
                    fw_default="0x1"
                    fw_signal="txpowerdown_mode"/>
                <node id="TXPLLPOWERDOWN" address="0x1" permission="rw"
                    mask="0x00400000"
                    description="Input to power down the TX PLL."
                    fw_default="0x0"
                    fw_signal="txpllpowerdown"/>
                <node id="FORCE_NOT_READY" address="0x1" permission="rw"
                    mask="0x00800000"
                    description="Set high to force MGTs not ready and gate the clocks for and reset the rest of the FPGA logic"
                    fw_default="0x0"
                    fw_signal="force_mgts_not_ready"/>

            </node> <!--Links-->

            <node id="SBIT_MONITOR" address="0x90"
                    description="sbit monitor module which shows the first valid sbit clusters after a reset on the selected link">
                <node id="RESET" address="0x0" permission="w"
                    description="Reset the sbit monitor module and re-arm for triggering"
                    fw_write_pulse_signal="reset_monitor"/>
                <node id="CLUSTER${CLUSTER_IDX}" address="0x1" mask="0x0000ffff" permission="r"
                    description="Last cluster ${CLUSTER_IDX}"
                    fw_signal="'0' &amp; frozen_cluster_${CLUSTER_IDX}(13 downto 11) &amp; '0' &amp; frozen_cluster_${CLUSTER_IDX} (10 downto 0)"
                    generate="true" generate_size="8" generate_address_step="0x1" generate_idx_var="CLUSTER_IDX"/>
                <node id="L1A_DELAY" address="0x10" mask="0xffffffff" permission="r"
                    description="Number of BX between this sbit and the subsequent L1A"
                    fw_signal="sbitmon_l1a_delay"/>
            </node>

            <node id="SBIT_HITMAP" address="0xb0"
                    description="The Sbit hitmap module accumulates all incoming Sbits during a period of time">
                <node id="RESET" address="0x0" permission="w"
                    description="Reset the accumulation registers"
                    fw_write_pulse_signal="hitmap_reset"/>
                <node id="ACQUIRE" address="0x1" mask="0x1" permission="rw"
                    description="Sbits are accumulated as long as this flag is set"
                    fw_signal="hitmap_acquire"
                    fw_default="0x0"/>
                <node id="VFAT${VFAT_HITMAP_IDX}_MSB" address="0x2" mask="0xffffffff" permission="r"
                    description="Accumulator for Sbit 63 to 32 of VFAT${VFAT_HITMAP_IDX}"
                    fw_signal="hitmap_sbits(${VFAT_HITMAP_IDX})(63 downto 32)"
                    generate="true" generate_size="12" generate_address_step="0x2" generate_idx_var="VFAT_HITMAP_IDX"/>
                <node id="VFAT${VFAT_HITMAP_IDX}_LSB" address="0x3" mask="0xffffffff" permission="r"
                    description="Accumulator for Sbit 31 to 0 of VFAT${VFAT_HITMAP_IDX}"
                    fw_signal="hitmap_sbits(${VFAT_HITMAP_IDX})(31 downto 0)"
                    generate="true" generate_size="12" generate_address_step="0x2" generate_idx_var="VFAT_HITMAP_IDX"/>
            </node>

    </node> <!--TRIG-->

    <!--Clocking module -->
    <node id="CLOCKING"  address="0x3000"
            description="Controls and monitors the status of the Optohybrid clocks"
            fw_is_module="true"
            fw_module_file="../src/utils/clocking.vhd"
            fw_user_clock_signal="clock"
            fw_bus_clock_signal="clock"
            fw_bus_reset_signal="ipb_reset_i"
            fw_master_bus_signal="ipb_mosi_i"
            fw_slave_bus_signal="ipb_miso_o"
            fw_reg_addr_msb="1"
            fw_reg_addr_lsb="0">

            <node id="MMCM_LOCKED" address="0x0" permission="r"
                mask="0x00000001"
                description="MMCM locked"
                fw_signal="mmcm_locked"/>
            <node id="MMCM_UNLOCKED_CNT" address="0x0" permission="r"
                mask="0x00ff0000"
                description="MMCM unlocked cnt"
                fw_cnt_en_signal="not mmcm_locked"
                fw_signal="mmcm_unlocked"/>
    </node>

    <!--GBT module -->
    <node id="GBT"  address="0x4000"
            description="Contains functionality for controlling and monitoring the bidirectional GBTx to FPGA link"
            fw_is_module="true"
            fw_module_file="../src/gbt/gbt.vhd"
            fw_user_clock_signal="clock_i"
            fw_bus_clock_signal="clock_i"
            fw_bus_reset_signal="ipb_reset_i"
            fw_master_bus_signal="ipb_mosi_i"
            fw_slave_bus_signal="ipb_miso_o"
            fw_reg_addr_msb="3"
            fw_reg_addr_lsb="0">

            <node id="TX" address="0x0" description = "Controls and monitors the transmit link from the FPGA to the GBTx">
                <node id="CNT_RESPONSE_SENT" address="0x0" permission="r"
                    mask="0xffffff00"
                    description="Number of wishbone responses sent back"
                    fw_cnt_en_signal="ipb_miso.ipb_ack"
                    fw_cnt_reset_signal="cnt_reset"
                    fw_cnt_snap_signal="cnt_snap"
                    fw_signal="cnt_ipb_response"/>
                <node id="TX_READY" address="0x1" permission="r"
                    mask="0x00000001"
                    description="GBT TX READY from GBTx Chip"
                    fw_signal="gbt_txready_i"/>
            </node> <!--TX-->

            <node id="RX" address="0x4" description = "Controls and monitors the transmit link from the GBTx to the FPGA">
                <node id="RX_READY" address="0x0" permission="r"
                    mask="0x00000001"
                    description="GBT RX READY from GBTx Chip"
                    fw_signal="gbt_rxready_i"/>
                <node id="RX_VALID" address="0x0" permission="r"
                    mask="0x00000002"
                    description="GBT RX VALID from GBTx Chip"
                    fw_signal="gbt_rxvalid_i"/>
                <node id="CNT_REQUEST_RECEIVED" address="0x0" permission="r"
                    mask="0xffffff00"
                    description="Number of wishbone requests received"
                    fw_cnt_en_signal="ipb_mosi.ipb_strobe"
                    fw_cnt_reset_signal="cnt_reset"
                    fw_cnt_snap_signal="cnt_snap"
                    fw_signal="cnt_ipb_request"/>
                <node id="CNT_LINK_ERR" address="0x1" permission="r"
                    mask="0x00ffffff"
                    description="Number of GBT link errrors detected"
                    fw_cnt_en_signal="gbt_link_err_ready"
                    fw_cnt_reset_signal="cnt_reset"
                    fw_cnt_snap_signal="cnt_snap"
                    fw_signal="cnt_link_err"/>
            </node> <!--RX-->

            <node id="TTC" address="0x5" description = "Emulates the TTC commands from GBTx through Wishbone">
            <node id="FORCE_L1A" address="0x0" permission="w"
                description="GBT Force L1A"
                fw_write_pulse_signal="l1a_force"/>
            <node id="FORCE_BC0" address="0x1" permission="w"
                description="GBT Force BC0"
                fw_write_pulse_signal="bc0_force"/>
            <node id="FORCE_RESYNC" address="0x2" permission="w"
                description="GBT Force Resync"
                fw_write_pulse_signal="resync_force"/>
            </node> <!--TTC-->


    </node> <!--GBT-->

</node> <!--FPGA-->

        <node id="GEB"  address="0x100000"
              description="VFAT3 registers">

            <node id="VFAT${VFAT_IDX}"  address="0x0"
                  description="VFAT ${VFAT_IDX}"
                  generate="true" generate_size="24" generate_address_step="0x00000800" generate_idx_var="VFAT_IDX">

              <node id="VFAT_CHANNELS"  address="0x0"
                    description="Registers for the individual VFAT channels
                                 Hardwired sleep value 0x00
                                 Software default value 0x00">
                <node id="CHANNEL${CHANNEL_IDX}"  address="0x00"  permission="rw"
                      description="Config register for VFAT channel ${CHANNEL_IDX}"
                      generate="true" generate_size="128" generate_address_step="0x1" generate_idx_var="CHANNEL_IDX">

                  <node id="CALPULSE_ENABLE"  address="0x0" mask="0x00008000"  permission="rw"
                        description="Enable the calibration pulse to the channel input">
                  </node>
                  <node id="MASK"  address="0x0" mask="0x00004000"  permission="rw"
                        description="Mask the channel output for trigger and readout">
                  </node>
                  <node id="ZCC_TRIM_POLARITY"  address="0x0" mask="0x00002000"  permission="rw"
                        description="Zero Crossing Comparator threshold trimming: correction polarity (0 = positive, 1 = negative)">
                  </node>
                  <node id="ZCC_TRIM_AMPLITUDE"  address="0x0" mask="0x00001f80"  permission="rw"
                        description="Zero Crossing Comparator threshold trimming: correction amplitude (steps of 0.5mV)">
                  </node>
                  <node id="ARM_TRIM_POLARITY"  address="0x0" mask="0x00000040"  permission="rw"
                        description="Arming Comparator threshold trimming: correction polarity (0 = positive, 1 = negative)">
                  </node>
                  <node id="ARM_TRIM_AMPLITUDE"  address="0x0" mask="0x0000003f"  permission="rw"
                        description="Arming Comparator threshold trimming: correction amplitude (steps of 0.5mV)">
                  </node>
                  
                </node>
              </node> <!-- end of VFATChannels -->

              <!-- a catch-all for all config registers (individual bits are extracted below), may want to use these registers for faster configuration to set all 32 bits at once instead of individual pieces -->
              <node id="CFG_${CFG_REG_IDX}"  address="0x81"  permission="rw"
                    description="VFAT control register number ${CFG_REG_IDX}"
                    generate="true" generate_size="17" generate_address_step="0x1" generate_idx_var="CFG_REG_IDX">
              </node>
              <!-- -->

              <node id="CFG_PULSE_STRETCH"  address="0x81" mask="0x0000e000"  permission="rw"
                    description="Pulse Stretcher control. Range is from 1 to 8 clock cycles (0 means 1 cycle, 7 means 8 cycles)">
              </node>
              <node id="CFG_SYNC_LEVEL_MODE"  address="0x81" mask="0x00000004"  permission="rw"
                    description="Switch the input synchronizer from edge to level mode (0 = edge, 1 = level)">
              </node>
              <node id="CFG_SELF_TRIGGER_MODE"  address="0x81" mask="0x00000002"  permission="rw"
                    description="Enable self trigger mode (0 = disable, 1 = enable)">
              </node>
              <node id="CFG_DDR_TRIGGER_MODE"  address="0x81" mask="0x00000001"  permission="rw"
                    description="Enable DDR trigger output mode (0 = SDR, 1 = DDR)">
              </node>

              <node id="CFG_SPZS_SUMMARY_ONLY"  address="0x82" mask="0x00008000"  permission="rw"
                    description="When set high, the SPZS mode will send only the 16bit partition summary (no sub-partition data at all)">
              </node>
              <node id="CFG_SPZS_MAX_PARTITIONS"  address="0x82" mask="0x00003c00"  permission="rw"
                    description="Maximum number of sub-partition data to send in SPZS mode (range: 1-16)">
              </node>
              <node id="CFG_SPZS_ENABLE"  address="0x82" mask="0x00000100"  permission="rw"
                    description="Enable SPZS zero suppression mode">
              </node>
              <node id="CFG_SZP_ENABLE"  address="0x82" mask="0x00000080"  permission="rw"
                    description="Enable SZP zero suppression mode (suppress zero packets -- only send the header)">
              </node>
              <node id="CFG_SZD_ENABLE"  address="0x82" mask="0x00000040"  permission="rw"
                    description="Enable SZD zero suppression mode (suppress zero data only -- still send header, EC, BC and CRC)">
              </node>
              <node id="CFG_TIME_TAG"  address="0x82" mask="0x00000030"  permission="rw"
                    description="Time tag format (00 = EC and BC, 01 = EC, 10 = BC, 11 = EC+BC)">
              </node>
              <node id="CFG_EC_BYTES"  address="0x82" mask="0x00000006"  permission="rw"
                    description="Event counter bytes (00 = 1B, 01 = 2B, 10 = 3B, 11 = 1B)">
              </node>
              <node id="CFG_BC_BYTES"  address="0x82" mask="0x00000001"  permission="rw"
                    description="Bunch counter bytes (0 = 2B, 1 = 3B)">
              </node>
              <node id="CFG_FP_FE"  address="0x83" mask="0x000000e0"  permission="rw"
                    description="Front end peaking time (000 = 25ns, 001 = 50ns, 011 = 75ns, 111 = 100ns)">
              </node>
              <node id="CFG_RES_PRE"  address="0x83" mask="0x0000001c"  permission="rw"
                    description="Preamplifier resistance set (001 = high gain, 010 = middle gain, 100 = low gain)">
              </node>
              <node id="CFG_CAP_PRE"  address="0x83" mask="0x00000003"  permission="rw"
                    description="Preamplifier capacity set (00 = high gain, 01 = middle gain, 11 = low gain)">
              </node>
              <node id="CFG_PT"  address="0x84" mask="0x000003c0"  permission="rw"
                    description="CFD Time Constant (0001 = 25ns, 0011 = 50ns, 0111 = 75ns, 1111 = 100ns)">
              </node>
              <node id="CFG_EN_HYST"  address="0x84" mask="0x00000020"  permission="rw"
                    description="Arming comparator hysteresis (0 = disable, 1 = enable)">
              </node>
              <node id="CFG_SEL_POL"  address="0x84" mask="0x00000010"  permission="rw"
                    description="CFD input charge polarity (0 = positive, 1 = negative/GEM )">
              </node>
              <node id="CFG_FORCE_EN_ZCC"  address="0x84" mask="0x00000008"  permission="rw"
                    description="Debug and calibration: force ZCC output, independent from arming comp (0 = disable, 1 = enable)">
              </node>
              <node id="CFG_FORCE_TH"  address="0x84" mask="0x00000004"  permission="rw"
                    description="Debug: force active ZCC threshold (0 = disable, 1 = enable)">
              </node>
              <node id="CFG_SEL_COMP_MODE"  address="0x84" mask="0x00000003"  permission="rw"
                    description="CFD output mode (00 = normal, 01 = arming, 10 = ZCC, 11 = 0)">
              </node>
              <node id="CFG_VREF_ADC"  address="0x85" mask="0x00000300"  permission="rw"
                    description="ADC internal reference tuning, 50mV steps to adjust to 1.0V during production calibration (range: 0-3)">
              </node>
              <node id="CFG_MON_GAIN"  address="0x85" mask="0x00000080"  permission="rw"
                    description="Gain of ADC monitoring buffer (0 = gain 1, 1 = gain 5)">
              </node>
              <node id="CFG_MONITOR_SELECT"  address="0x85" mask="0x0000003f"  permission="rw"
                    description="Monitoring selection (0 = Imon Iref, 1 = Imon Calib IDC, 2 = Imon Preamp InpTran, 3 = Imon Preamp LC, 4 = Imon Preamp SF, 5 = Imon Shap FC, 6 = Imon Shap Inpair, 7 = Imon SD Inpair, 8 = Imon SD FC, 9 = Imon SD SF, 10 = Imon CFD Bias1, 11 = Imon CFD Bias2, 12 = Imon CFD Hyst, 13 = Imon CFD Ireflocal, 14 = Imon CFD ThArm, 15 = Imon CFD ThZcc, 16 = Imon SLVS Ibias, 32 = Vmon BGR, 33 = Vmon Calib Vstep, 34 = Vmon Preamp Vref, 35 = Vmon Vth Arm, 36 = Vmon Vth ZCC, 37 = V Tsens Int, 38 = V Tsens Ext, 39 = ADC ref, 40 = ADC VinM, 41 = SLVS Vref">
              </node>
              <node id="CFG_IREF"  address="0x86" mask="0x0000003f"  permission="rw"
                    description="Tuning of global reference current generated by Bandgap reference circuit. Target value: 10uA. Nominal: 310nA/bit">
              </node>

              <node id="CFG_THR_ZCC_DAC"  address="0x87" mask="0x0000ff00" permission="rw"
                    description="ZCC global threshold: nominal 0.5mV/bit (range: 0x00-0xff)">
              </node>
              <node id="CFG_THR_ARM_DAC"  address="0x87" mask="0x000000ff" permission="rw"
                    description="Arming global threshold: nominal 2mV/bit (range: 0x00-0xff)">
              </node>

              <node id="CFG_HYST"  address="0x88" mask="0x0000003f" permission="rw"
                    description="Global hysteresis DAC: nominal 0.4mV/bit (range: 0x00-0x3f)">
              </node>

              <node id="CFG_LATENCY"  address="0x89" mask="0x0000ffff" permission="rw"
                    description="Internal L1A latency (range: 0-1023)">
              </node>

              <node id="CFG_CAL_SEL_POL"  address="0x8a" mask="0x00004000" permission="rw"
                    description="Calibration pulse polarity (0 = positive, 1 = negative)">
              </node>
              <node id="CFG_CAL_PHI"  address="0x8a" mask="0x00003800" permission="rw"
                    description="Pulse phase in 1/320MHz (3.125ns) delay (range: 0-7, where 0 = no delay and 7 = 21.87ns)">
              </node>
              <node id="CFG_CAL_EXT"  address="0x8a" mask="0x00000400" permission="rw"
                    description="External analog voltage step (0 = disable, 1 = enable)">
              </node>
              <node id="CFG_CAL_DAC"  address="0x8a" mask="0x000003fc" permission="rw"
                    description="CAL DAC: amplitude of current pulse. 256-CAL DAC: amplitude of voltage step. Range: 0-255">
              </node>
              <node id="CFG_CAL_MODE"  address="0x8a" mask="0x00000003" permission="rw"
                    description="Cal pulse mode (00 = disabled, 01 = voltage pulse, 1x = current pulse">
              </node>
              <node id="CFG_CAL_FS"  address="0x8b" mask="0x00000600" permission="rw"
                    description="Cal current pulse scale factor. Q = CAL DUR[s] * CAL DAC * 10nA * CAL FS[%] (00 = 25%, 01 = 50%, 10 = 75%, 11 = 100%)">
              </node>
              <node id="CFG_CAL_DUR"  address="0x8b" mask="0x000001ff" permission="rw"
                    description="Cal pulse duration in 40MHz clock cycles (range: 0-0x1ff)">
              </node>

              <node id="CFG_BIAS_CFD_DAC_2"  address="0x8c" mask="0x00000fc0" permission="rw"
                    description="CFD Bias 2 (current). Range: 0-0x3f (default = 0x28)">
              </node>
              <node id="CFG_BIAS_CFD_DAC_1"  address="0x8c" mask="0x0000003f" permission="rw"
                    description="CFD Bias 1 (current). Range: 0-0x3f (default = 0x28)">
              </node>
              <node id="CFG_BIAS_PRE_I_BSF"  address="0x8d" mask="0x00003f00" permission="rw"
                    description="Preamplifier bias source follower (current). Range: 0-0x3f (default = 1 = 2uA)">
              </node>
              <node id="CFG_BIAS_PRE_I_BIT"  address="0x8d" mask="0x000000ff" permission="rw"
                    description="Preamplifier bias input transistor (current). Range: 0-0xff (default = 1 = 1uA)">
              </node>
              <node id="CFG_BIAS_PRE_I_BLCC"  address="0x8e" mask="0x00003f00" permission="rw"
                    description="Preamplifier bias leakage compensation (current). Range: 0-0x3f (default = 15 = 15nA)">
              </node>
              <node id="CFG_BIAS_PRE_VREF"  address="0x8e" mask="0x000000ff" permission="rw"
                    description="Preamplifier VREF. Range: 0-0xff (default = 86 = 430mV)">
              </node>
              <node id="CFG_BIAS_SH_I_BFCAS"  address="0x8f" mask="0x0000ff00" permission="rw"
                    description="Shaper folded cascode (current). Range: 0-0xff (default = 1 = 100nA)">
              </node>
              <node id="CFG_BIAS_SH_I_BDIFF"  address="0x8f" mask="0x000000ff" permission="rw"
                    description="Shaper input pair (current). Range: 0-0xff (default = 1 = 100nA)">
              </node>
              <node id="CFG_BIAS_SH_I_BFAMP"  address="0x90" mask="0x00003f00" permission="rw"
                    description="Shaper feed amplifier (current). Range: 0-0x3f (default = 1 = 1nA)">
              </node>
              <node id="CFG_BIAS_SD_I_BDIFF"  address="0x90" mask="0x000000ff" permission="rw"
                    description="SD input pair (current). Range: 0-0xff (default = 1 = 100nA)">
              </node>
              <node id="CFG_BIAS_SD_I_BSF"  address="0x91" mask="0x00003f00" permission="rw"
                    description="SD source follower (current). Range: 0-0x3f (default = 1 = 2uA)">
              </node>
              <node id="CFG_BIAS_SD_I_BFCAS"  address="0x91" mask="0x000000ff" permission="rw"
                    description="SD folded cascode (current). Range: 0-0xff (default = 1 = 100nA)">
              </node>

              <node id="CFG_RUN" address="0x300" mask="0x00000001" permission="rw"
                    description="SLEEP/RUN mode (0 = SLEEP, 1 = RUN)">
              </node>

              <node id="HW_ID"  address="0x100"  permission="r"
                    description="Device hardware ID register. Reports 0x56464154 (ASCII 'VFAT') on read.">
              </node>
              <node id="HW_ID_VER"  address="0x101"  permission="r"
                    description="Hardware version. Reports 0x00030000 (v3.0.0) on read.">
              </node>
              <node id="TEST_REG"  address="0x102"  permission="rw"
                    description="General purpose read/write register.">
              </node>
              <node id="HW_CHIP_ID"  address="0x103"  permission="r"
                    description="Chip ID from eFuses.">
              </node>
              
              <!-- probably better to leave these out as they should only be used during fusing
              <node id="HW_PROG_TIME"  address="0x104" mask="0x0007ff00" permission="w"
                    description="eFuse: program time in 25ns units. Range: 0-0x7ff">
              </node>
              <node id="HW_PROG_BIT_ADDR"  address="0x104" mask="0x0000001f" permission="w"
                    description="eFuse: address of the bit to be programmed. Range: 0-0x1f">
              </node>
              -->

              <node id="ADC0_CACHED"  address="0x280" mask="0x000003ff" permission="r"
                    description="Primary ADC read (using the internal reference). Note, this value is returned from CTP7's cache (last known value of ADC0 for this VFAT since ADC0_UPDATE was called). To update the cache, read or write ADC0_UPDATE, and wait at least 20us before reading this register to take the updated value (note that value of 0 indicates a read error)">
              </node>
              <node id="ADC0_UPDATE"  address="0x200" mask="0x00000001" permission="rw"
                    description="Reading or writing this register will trigger a read of the ADC0 value form this VFAT and update of the cache. The read from the VFAT takes aroun 11us, so it's advised to wait for 20us to be sure that the cache was already updated before reading ADC0_CACHED">
              </node>

              <node id="ADC1_CACHED"  address="0x281" mask="0x000003ff" permission="r"
                    description="ADC1 read (using the external reference). Note, this value is returned from CTP7's cache. To update the cache, read or write ADC1_UPDATE, and wait at least 20us before reading this register to take the updated value (note that value of 0 indicates a read error)">
              </node>
              <node id="ADC1_UPDATE"  address="0x201" mask="0x00000001" permission="rw"
                    description="Reading or writing this register will trigger a read of the ADC1 value form this VFAT and update of the cache. The read from the VFAT takes aroun 11us, so it's advised to wait for 20us to be sure that the cache was already updated before reading ADC1_CACHED">
              </node>

            </node>
        </node>


      </node> <!-- end OH${OH_IDX} block -->
    </node> <!-- end OptoHybrid block -->

    <!--Config Blaster module -->
    <node id="CONFIG_BLASTER"  address="0x00c00000"
          description="Configuration Blaster. This module stores configuration data for all GBTXs, VFAT3s, and OH FPGAs, and then streams this configuration data to each device after a hard-reset."
          fw_is_module="true"
          fw_is_module_external="true">

      <node id="CTRL" address="0x0">
        <node id="BLASTER_ENABLE" address="0x0" mask="0x00000001" permission="rw"
              description="Set this to 1 to enable the configuration blasting after the hard reset. By default this is disabled, because config RAM is empty on startup, so only enable this after the config RAM has been written with valid config data.">
        </node>
      </node>        

      <node id="STATUS" address="0x100">
        <node id="GBT_RAM_SIZE" address="0x0" permission="r" description="Size of the GBT config RAM (in 32bit words, or number of available addresses)"/>
        <node id="VFAT_RAM_SIZE" address="0x1" permission="r" description="Size of the VFAT config RAM (in 32bit words, or number of available addresses)"/>
        <node id="OH_RAM_SIZE" address="0x2" permission="r" description="Size of the OH config RAM (in 32bit words, or number of available addresses)"/>
      </node>        

      <node id="RAM" address="0x10000">
        <node id="GBT" address="0x00000" mode="block" size="3312" permission="rw"
              description="Configuration RAM for GBTX chips. Each GBTX has 366 x 8bit registers, and each address in this RAM holds 4 register values in LSB format (so in total there are 92 RAM addresses for each chip, where the last one is only partially filled).
                           The actual RAM in the firmware is sized according to the number of OH links present in the firmware, so software should check how many OHs are supported by the firmware and only fill out the corresponding number of configuration entries.
                           RAM size is also provided in the STATUS registers of this module.
                           If the software attempts to write outside the bounds of the RAM, it may be overwriting other data."/>
        <node id="VFAT" address="0x10000" mode="block" size="21312" permission="rw"
              description="Configuration RAM for VFAT chips. Each VFAT has 147 x 16bit registers, and each address in this RAM holds 2 register values in LSB format (so in total there are 74 RAM addresses for each chip, where the last one is only partially filled).
                           The actual RAM in the firmware is sized according to the number of OH links present in the firmware, so software should check how many OHs are supported by the firmware and only fill out the corresponding number of configuration entries.
                           RAM size is also provided in the STATUS registers of this module.
                           If the software attempts to write outside the bounds of the RAM, it may be overwriting other data."/>

        <node id="OH_FPGA" address="0x20000" mode="block" size="2400" permission="rw"
              description="Configuration RAM for OH FPGAs. 100 32bit registers are allocated for each OH at the moment. For each register, a 32bit OH register address (local to OH address space) has to be written to this RAM, followed by a 32bit register value.
                           The actual RAM in the firmware is sized according to the number of OH links present in the firmware, so software should check how many OHs are supported by the firmware and only fill out the corresponding number of configuration entries.
                           RAM size is also provided in the STATUS registers of this module.
                           If the software attempts to write outside the bounds of the RAM, it may be overwriting other data."/>
        <node id="GBT_OH${OH_IDX}"  address="0x00000" mode="block" size="276" permission="rw"
              description="GBTX configuration RAM pointer to OH${OH_IDX}. This part of the RAM contains configuration of all 3 GBTXs for this OH."
	      generate="true" generate_size="2" generate_address_step="0x144" generate_idx_var="OH_IDX"/>
        <node id="VFAT_OH${OH_IDX}"  address="0x10000" mode="block" size="1776" permission="rw"
              description="VFAT configuration RAM pointer to OH#${OH_IDX}. This part of the RAM contains configuration of all 24 VFATs for this OH."
	      generate="true" generate_size="2" generate_address_step="0x6f0" generate_idx_var="OH_IDX"/>
        <node id="OH_FPGA_OH${OH_IDX}"  address="0x20000" mode="block" size="200" permission="rw"
              description="OH FPGA configuration RAM pointer to OH#${OH_IDX}."
	      generate="true" generate_size="2" generate_address_step="0xc8" generate_idx_var="OH_IDX"/>
      </node>

    </node> <!-- end Config Blaster block -->

    <!-- Optical links module -->
    <node id="OPTICAL_LINKS"  address="0x1400000"
          description="This module contains counters and control registers of all the optical links on the board (regardless of link rate or what they connect to)"
          fw_is_module="true"
          fw_is_module_external="true">

      <node id="DISABLE_TTC_PHASE_ALIGN" address="0x11000" mask="0x00000001" permission="rw"
            description="Disables TTC phase alignment when set to 1 (default is 0). In setups that don't have AMC13 and are running on local oscillator clock, this should be set to 1 immediately after programming the CTP7 FPGA, which will allow the optical links to initialize. Otherwise this register should not be touched, except perhaps it could be toggled in case there has been a TTC clock interruption, which should realign the fabric clocks to it (note that GTH reset is required after such action)"/>

      <node id="MGT_CHANNEL_${MGT}" address="0x0"
            description="MGT channel ${MGT} control and status. Note: these are MGT channles, which do not correspond 1-to-1 with the fiber numbering. Please refer here for MGT channel to fiber mapping: https://docs.google.com/spreadsheets/d/1-AE7GeeU10GfLB-9FYOMN4k0-Z7bVkiQpLfXC4G2irI"
            generate="true" generate_size="64" generate_address_step="0x00000040" generate_idx_var="MGT">

        <node id="RESET" address="0x1" permission="rw"
              description="Writing 1 to bit 0 will trigger MGT TX channel reset, and writing 1 to bit 1 will trigger the MGT RX channel reset (write 3 to trigger both)">
          <node id="TX_RESET" address="0x0" mask="0x00000001" permission="rw"
                description="Writing 1 to this reg will trigger MGT TX channel reset"/>
          <node id="RX_RESET" address="0x0" mask="0x00000002" permission="rw"
                description="Writing 1 to this reg will trigger MGT RX channel reset"/>
        </node>

        <node id="CTRL" address="0x2" permission="rw"
              description="This register exposes multiple MGT controls: bit 0 -- TX powerdown, bit 1 -- RX powerdown, bit 2 -- TX polarity, bit 3 -- RX polarity, bit 4 -- loopback, bit 5 -- TX inhibit, bit 6 -- RX low power mode enable">
          <node id="TX_POWERDOWN" address="0x0" mask="0x00000001" permission="rw"
                description="Setting this to 1 will powerdown the TX (writes 11 to TXPD), and 0 will put it in normal power mode (writes 00 to TXPD)"/>
          <node id="RX_POWERDOWN" address="0x0" mask="0x00000002" permission="rw"
                description="Setting this to 1 will powerdown the RX (writes 11 to RXPD), and 0 will put it in normal power mode (writes 00 to RXPD)"/>
          <node id="TX_POLARITY" address="0x0" mask="0x00000004" permission="rw"
                description="Setting this to 1 will invert the polarity of TX, setting to 0 will result in normal TX polarity"/>
          <node id="RX_POLARITY" address="0x0" mask="0x00000008" permission="rw"
                description="Setting this to 1 will invert the polarity of RX, setting to 0 will result in normal RX polarity"/>
          <node id="LOOPBACK" address="0x0" mask="0x00000010" permission="rw"
                description="Setting this to 1 will enable the near-end PMA loopback of the MGT (sets MGT LOOPBACK port to 010). This is an expert debug feature."/>
          <node id="TX_INHIBIT" address="0x0" mask="0x00000020" permission="rw"
                description="Setting this to 1 will inhibit the TX channel (forces MGTHTXP to 0 and MGTHTXN to 1). This is an expert debug feature."/>
          <node id="RX_LOW_POWER_MODE" address="0x0" mask="0x00000040" permission="rw"
                description="Setting this to 1 enables the RX LPM (this controls RXLPMEN). NOTE: THIS MUST ALWAYS BE SET TO 1 FOR GOOD RX PERFORMANCE WITH 8b10b ENCODING."/>
          <node id="RX_PRBS_SEL" address="0x1" mask="0x00000007" permission="rw"
                description="Controls the RX PRBS mode: 000 -- normal operation (no PRBS checks), 001 -- PRBS7, 010 -- PRBS15, 011 -- PRBS23, 100 -- PRBS31"/>
          <node id="TX_PRBS_SEL" address="0x1" mask="0x00000070" permission="rw"
                description="Controls the TX PRBS mode: 000 -- normal operation (no PRBS), 001 -- PRBS7, 010 -- PRBS15, 011 -- PRBS23, 100 -- PRBS31, 101 -- PCIe compliance patteren, 110 -- square wave with 2 UI (alternating 0s and 1s), 111 -- square wave with 16 UI, 20 UI, 32 UI or 40 UI period depending on data width"/>
          <node id="PRBS_CNT_RESET" address="0x2" mask="0x00000001" permission="w"
                description="Writing 1 here resets the PRBS error counters"/>
          <node id="RX_ERROR_CNT_RESET" address="0x3" mask="0x00000001" permission="w"
                description="Writing 1 here resets the RX error counters for this channel (not in table and disperr)"/>
        </node>

        <node id="STATUS" address="0x0" permission="r">
          <node id="TX_RESET_DONE" address="0x0" mask="0x00000001" permission="r"
                description="TX reset done signal"/>
          <node id="RX_RESET_DONE" address="0x0" mask="0x00000002" permission="r"
                description="RX reset done signal"/>
          <node id="CPLL_LOCKED" address="0x0" mask="0x00000004" permission="r"
                description="CPLL locked signal"/>
          <node id="CPLL_REF_CLK_LOST" address="0x0" mask="0x00000008" permission="r"
                description="CPLL reference clock is lost if this is 1"/>
          <node id="PRBS_ERROR_CNT" address="0x4" permission="r"
                description="PRBS error counter"/>
          <node id="PRBS_ERROR_CNT" address="0x4" permission="r"
                description="PRBS error counter"/>
          <node id="RX_NOT_IN_TABLE_CNT" address="0x5" permission="r"
                description="RX not-in-table counter"/>
          <node id="RX_DISPERR_CNT" address="0x6" permission="r"
                description="RX disparity error counter"/>
        </node>

      </node>

    </node> <!--End of optical links module -->

    <node id="GLIB_SYSTEM" address="0x910000"
          description="Legacy system registers (taken from GLIB system core).
                       These should be removed once the software is made compatible with the new system registers."
          fw_is_module="true"
          fw_is_module_external="true">

      <node id="SYSTEM"  address="0x00000000"  permission="r"
            description="GLIB system registers">
        <node id="BOARD_ID" address="0x0"
              description="GLIB board ID code">
          <node id="CHAR1"  mask="0xff000000"  permission="r" address="0x00000000"/>
          <node id="CHAR2"  mask="0x00ff0000"  permission="r" address="0x00000000"/>
          <node id="CHAR3"  mask="0x0000ff00"  permission="r" address="0x00000000"/>
          <node id="CHAR4"  mask="0x000000ff"  permission="r" address="0x00000000"/>
        </node> <!--end board_id -->

        <node id="SYSTEM_ID"  address="0x1" permission="r"
              description="GLIB system ID code">
          <node id="CHAR1"  mask="0xff000000"  permission="r" address="0x00000000"/>
          <node id="CHAR2"  mask="0x00ff0000"  permission="r" address="0x00000000"/>
          <node id="CHAR3"  mask="0x0000ff00"  permission="r" address="0x00000000"/>
          <node id="CHAR4"  mask="0x000000ff"  permission="r" address="0x00000000"/>
        </node> <!--end system_id -->

        <node id="FIRMWARE"  address="0x2"  permission="r"
              description="GLIB firmware date (dd.mm.yy) and version number (x.y.z)">
          <node id="ID"     mask="0xffff0000"    permission="r" address="0x00000000"/>
          <node id="MAJOR"  mask="0xf0000000"    permission="r" address="0x00000000"/>
          <node id="MINOR"  mask="0x0f000000"    permission="r" address="0x00000000"/>
          <node id="BUILD"  mask="0x00ff0000"    permission="r" address="0x00000000"/>
          <node id="DATE"   mask="0x0000ffff"    permission="r" address="0x00000000"/>
          <node id="YY"     mask="0x0000fe00"    permission="r" address="0x00000000"/>
          <node id="MM"     mask="0x000001e0"    permission="r" address="0x00000000"/>
          <node id="DD"     mask="0x0000001f"    permission="r" address="0x00000000"/>
        </node> <!--end firmware_id -->

        <node id="TEST"  address="0x0"     permission="r"
              description="Register for testing purposes only"/>

        <node id="CLK_CTRL"  address="0x0"
              description="Controls the external clocking circuitry">
          <node id="PCIE_CLK_FSEL"	  mask="0x00000001" address="0x0" permission="r"
                description="output multiplication factor:0->2.5x, 1->1.25x"/>
          <node id="PCIE_CLK_MR"	  mask="0x00000002" address="0x0" permission="r"
                description="master reset: 1 -> reset, 0 -> normal"/>
          <node id="PCIE_CLK_OE"	  mask="0x00000004" address="0x0" permission="r"
                description="output enable"/>
          <node id="CDCE_POWERUP"	  mask="0x00000010" address="0x0" permission="r"
                description="control power up of CDCE"/>
          <node id="CDCE_REFSEL"	  mask="0x00000020" address="0x0" permission="r"
                description="clock input selection: 1 -> CLK1, 0 -> CLK2"/>
          <node id="CDCE_SYNC"	          mask="0x00000040" address="0x0" permission="r"
                description="CDCE synchronization, transition from 0 to 1 needed to resync"/>
          <node id="CDCE_CTRLSEL"         mask="0x00000080" address="0x0" permission="r"
                description="who drives CDCE: 0 -> system, 1 -> user"/>
          <node id="TCLKB_DR_EN"	  mask="0x00000200" address="0x0" permission="r"
                description="TCKLB to backplane enable"/>
          <node id="XPOINT2" address="0x0" permission="r"
                description="configure the routing of the clocks on the xpoint2 switch
                             if bit 0 is 0 and bit 1 is 0, the output takes input 1 as the source
                             if bit 0 is 0 and bit 1 is 1, the output takes input 2 as the source
                             if bit 0 is 1 and bit 1 is 0, the output takes input 3 as the source
                             if bit 0 is 1 and bit 1 is 1, the output takes input 4 as the source
                             ">
            <node id="S10"	  mask="0x00001000" address="0x0" permission="r"
                  description="output 1 first bit"/>
            <node id="S11"	  mask="0x00002000" address="0x0" permission="r"
                  description="output 1 second bit"/>
          </node> <!-- end xpoint2 configuration-->
          <node id="XPOINT1" address="0x0" permission="r"
                description="configure the routing of the clocks on the xpoint1 switch
                             if bit 0 is 0 and bit 1 is 0, the output takes input 1 as the source
                             if bit 0 is 0 and bit 1 is 1, the output takes input 2 as the source
                             if bit 0 is 1 and bit 1 is 0, the output takes input 3 as the source
                             if bit 0 is 1 and bit 1 is 1, the output takes input 4 as the source
                             ">
            <node id="S10"	  mask="0x00010000" address="0x0" permission="r"
                  description="output 1 first bit"/>
            <node id="S11"	  mask="0x00020000" address="0x0" permission="r"
                  description="output 1 second bit"/>
            <node id="S20"	  mask="0x00040000" address="0x0" permission="r"
                  description="output 2 first bit"/>
            <node id="S21"	  mask="0x00080000" address="0x0" permission="r"
                  description="output 2 second bit"/>
            <node id="S30"	  mask="0x00100000" address="0x0" permission="r"
                  description="output 3 first bit"/>
            <node id="S31"	  mask="0x00200000" address="0x0" permission="r"
                  description="output 3 second bit"/>
            <node id="S40"	  mask="0x00400000" address="0x0" permission="r"
                  description="output 4 first bit"/>
            <node id="S41"	  mask="0x00800000" address="0x0" permission="r"
                  description="output 4 second bit"/>
          </node> <!-- end xpoint1 configuration-->

          <node id="GBT_PHASE_MON_RESET"  mask="0x04000000" address="0x0" permission="r"
                description=""/>
          <node id="FPGA_PROGRAM_B_TRST"  mask="0x10000000" address="0x0" permission="r"
                description=""/>
        </node> <!--end ctrl-->

        <node id="FLASH_CTRL"  address="0x0"  permission="r"
              description="Flash control register">
          <node id="ICAP_PAGE"   mask="0x00000003" address="0x0"  permission="r"/>
          <node id="ICAP_TRIGG"  mask="0x00000010" address="0x0"  permission="r"/>
        </node> <!--end ctrl_2-->

        <node id="STATUS"  address="0x0"
              description="Status from various external components">
          <node id="SFP1"
                description="status bits for SFP cage 1">
            <node id="STATUS"      mask="0x00000007" address="0x0"  permission="r"
                  description="SFP1 status, bit 1 Mod_abs, bit 2 RxLOS, bit 3 TxFault"/>
            <node id="Mod_abs"     mask="0x00000001" address="0x0"  permission="r"/>
            <node id="RxLOS" 	   mask="0x00000002" address="0x0"  permission="r"/>
            <node id="TxFault"     mask="0x00000004" address="0x0"  permission="r"/>
          </node>

          <node id="SFP2"
                description="status bits for SFP cage 2">
            <node id="STATUS"      mask="0x00000070" address="0x0"  permission="r"
                  description="SFP2 status, bit 1 Mod_abs, bit 2 RxLOS, bit 3 TxFault"/>
            <node id="Mod_abs"     mask="0x00000010" address="0x0"  permission="r"/>
            <node id="RxLOS" 	   mask="0x00000020" address="0x0"  permission="r"/>
            <node id="TxFault"     mask="0x00000040" address="0x0"  permission="r"/>
          </node>

          <node id="SFP3"
                description="status bits for SFP cage 3">
            <node id="STATUS"      mask="0x00000700" address="0x0"  permission="r"
                  description="SFP3 status, bit 1 Mod_abs, bit 2 RxLOS, bit 3 TxFault"/>
            <node id="Mod_abs"     mask="0x00000100" address="0x0"  permission="r"/>
            <node id="RxLOS" 	   mask="0x00000200" address="0x0"  permission="r"/>
            <node id="TxFault"     mask="0x00000400" address="0x0"  permission="r"/>
          </node>

          <node id="SFP4"
                description="status bits for SFP cage 4">
            <node id="STATUS"      mask="0x00007000" address="0x0"  permission="r"
                  description="SFP4 status, bit 1 Mod_abs, bit 2 RxLOS, bit 3 TxFault"/>
            <node id="Mod_abs"     mask="0x00001000" address="0x0"  permission="r"/>
            <node id="RxLOS" 	   mask="0x00002000" address="0x0"  permission="r"/>
            <node id="TxFault"     mask="0x00004000" address="0x0"  permission="r"/>
          </node>

          <node id="GBE_INT" 		   mask="0x00010000" address="0x0"  permission="r"
                description="GBE Phy interrupt"/>
          <node id="FMC1_PRESENT"    	   mask="0x00020000" address="0x0"  permission="r"
                description="FMC present in FMC slot 1"/>
          <node id="FMC2_PRESENT"    	   mask="0x00040000" address="0x0"  permission="r"
                description="FMC present in FMC slot 2"/>
          <node id="FPGA_RESET"	           mask="0x00080000" address="0x0"  permission="r"
                description="state of the FPGA reset line, driven by the CPLD"/>
          <node id="V6_CPLD"         	   mask="0x03f00000" address="0x0"  permission="r"
                description="state of the 6-bit bus between the FPGA and the CPLD"/>
          <node id="CDCE_LOCK"             mask="0x08000000" address="0x0"  permission="r"
                description="State of the CDCE"/>

          <node id="SFP_PHASE_MON"
                description="">
            <node id="DONE"    mask="0x10000000" address="0x0"  permission="r"
                  description=""/>
            <node id="OK"      mask="0x20000000" address="0x0"  permission="r"
                  description=""/>
          </node>

          <node id="FMC1_PHASE_MON"
                description="">
            <node id="DONE"   mask="0x40000000" address="0x0"  permission="r"
                  description=""/>
            <node id="OK"     mask="0x80000000" address="0x0"  permission="r"
                  description=""/>
          </node>
        </node>

        <node id="STATUS_2"   address="0x0"   permission="r"
              description="Currently unused"/>

        <node id="SRAM" address="0x0"
              description="SRAM interface control and status registers, and banks 1 and 2">
          <node id="CTRL" address="0x0"  permission="r"
                description="SRAM interface control register">
            <node id="SRAM1_USER_LOGIC"	mask="0x00000001" address="0x0"  permission="r"/>
            <node id="SRAM1_BIST_RUN"	mask="0x00000002" address="0x0"  permission="r"/>
            <node id="SRAM2_USER_LOGIC"	mask="0x00010000" address="0x0"  permission="r"/>
            <node id="SRAM2_BIST_RUN"	mask="0x00020000" address="0x0"  permission="r"/>
            <node id="FLASH_SELECT"	mask="0x00100000" address="0x0"  permission="r"/>
          </node> <!--end ctrl_sram-->

          <node id="STATUS"  address="0x0"  permission="r"
                description="SRAM interface status register">
            <node id="SRAM1_BIST_DONE"	  mask="0x00000001" address="0x0"  permission="r"/>
            <node id="SRAM1_BIST_OK"	  mask="0x00000002" address="0x0"  permission="r"/>
            <node id="SRAM1_BIST_ERRORS"  mask="0x00000ff0" address="0x0"  permission="r"/>
            <node id="SRAM2_BIST_DONE"	  mask="0x00010000" address="0x0"  permission="r"/>
            <node id="SRAM2_BIST_OK"	  mask="0x00020000" address="0x0"  permission="r"/>
            <node id="SRAM2_BIST_ERRORS"  mask="0x0ff00000" address="0x0"  permission="r"/>
          </node> <!--end status_sram-->
        </node>

        <node id="SPI"  address="0x0"
              description="SPI interface: data from FPGA to clock synthesizer">
          <node id="TxDATA"  address="0x0"   permission="r"
                description="SPI interface: data from FPGA to clock synthesizer"/>

          <node id="COM"  address="0x0"  permission="r"
                description="SPI interface: configuration (polarity, phase, frequency, etc.,">
            <node id="Autoclear"  mask="0xf0000000" address="0x0"  permission="r"
                  description=""/>
            <node id="Reserved"   mask="0x0ffff000"  address="0x0"  permission="r"
                  description="reserved, always keep to 0xFA38"/>
            <node id="Prescale"   mask="0x00000fff" address="0x0"  permission="r"
                  description="SPI clk (MHz)=62.5/prescaler, suggested default 0x014"/>
            <node id="Strobe"     mask="0x80000000" address="0x0"  permission="r"
                  description="execute transaction, clears automatically"/>
          </node> <!--end spi_command register-->

          <node id="RxDATA"  address="0x0"   permission="r"
                description="SPI interface: data from clock synthesizer to FPGA"/>
        </node>

        <node id="I2C"  address="0x0"
              description="I2C interface">
          <node id="SETTINGS"  address="0x0"  permission="r"
                description="I2C interface: configuration (bus select, frequency, etc., only in bench mode)">
            <node id="ENABLE"      mask="0x00000800" address="0x0"  permission="r"
                  description="for FW version 5.3 and higher, enable is bit 15(0x8000) instead of bit 11(0x800)"/>
            <node id="Reserved"    mask="0x00001000" address="0x0"  permission="r"
                  description="for FW version 5.3 and higher, reserved bits are [14:13](0x6000) instead of bit 12(0x1000)"/>
            <node id="BUS_SELECT"  mask="0x00000400" address="0x0"  permission="r"
                  description="for FW version 5.3 and higher, bus select is [12:10](0x1c00) instead of just bit 10(0x400)"/>
            <node id="PRESCALER"   mask="0x000003ff" address="0x0"  permission="r"
                  description="I2C clk(kHz)=62.5/prescale"/>
          </node> <!--end i2c_settings-->

          <node id="COM"  address="0x0"  permission="r"
                description="I2C interface: transaction parameters (slave address, drive to slave, etc., only in bench mode)">
            <node id="Autoclear"   mask="0xf0000000" address="0x0"  permission="r"
                  description="special feature of this register, clears automatically the upper 4 bits"/>
            <node id="Strobe"      mask="0x80000000" address="0x0"  permission="r"
                  description="Execute I2C strobe signal, autoclears"/>
            <node id="MODE16"      mask="0x02000000" address="0x0"  permission="r"
                  description="16-bit operation mode, (PHY only) 0-> standard 8-bit mode, 1->16-bit mode"/>
            <node id="Res2"        mask="0x01000000"  address="0x0"  permission="r"
                  description="reserved, keep to 0"/>
            <node id="WRITE"       mask="0x00800000" address="0x0"  permission="r"
                  description="Write enable"/>
            <node id="SLV_ADDR"    mask="0x007f0000" address="0x0"  permission="r"
                  description="Slave address"/>
            <node id="Res"         mask="0x0000ff00" address="0x0"  permission="r"
                  description="reserved, keep to 0x00"/>
            <node id="WRDATA"      mask="0x000000ff" address="0x0"  permission="r"
                  description="Byte to write to the I2C slave"/>
          </node> <!--end i2c_command-->

          <node id="REPLY"  address="0x0"  permission="r"
                description="I2C interface: transaction reply (status, data from drive, etc., only in bench mode">
            <node id="STATUS"  mask="0x0c000000" address="0x0"  permission="r"
                  description="status bits: 01->success, 11->failed,00/10->pending"/>
            <node id="DATA_LO" mask="0x000000ff" address="0x0"  permission="r"
                  description="low 8 bits of reply"/>
            <node id="DATA_HI" mask="0x0000ff00" address="0x0"  permission="r"
                  description="high 8 bits of reply"/>
            <node id="8b"      mask="0x000000ff" address="0x0"  permission="r"
                  description="8-bit reply"/>
            <node id="16b"     mask="0x0000ffff" address="0x0"  permission="r"
                  description="Full 16 bit reply"/>
          </node> <!--end i2c_reply-->
        </node>

        <node id="SFP_PHASE_MON">
          <node id="CTRL"  address="0x0"  permission="r"
              description="">
            <node id="LOWER"  mask="0x000000ff" address="0x0"  permission="r"/>
            <node id="UPPER"  mask="0x0000ff00" address="0x0"  permission="r"/>
          </node> <!--end sfp_phase_mon_ctrl-->

          <node id="STATS"  address="0x0"   permission="r"
              description=""/>
        </node> <!--end sfp_phase_mon-->

        <node id="FMC1_PHASE_MON">
          <node id="CTRL"  address="0x0"  permission="r"
                description="">
            <node id="LOWER"  mask="0x000000ff" address="0x0"  permission="r"/>
            <node id="UPPER"  mask="0x0000ff00" address="0x0"  permission="r"/>
          </node> <!--end fmc1_phase_mon_ctrl-->

          <node id="STATS"  address="0x0"   permission="r"
              description=""/>
        </node> <!--end fmc1_phase_mon-->

        <node id="MAC"  address="0x0"  permission="r"
              description="firmware version 5.3 and above has different values, as in the description">
          <node id="IP_SOURCE"  address="0x0"  permission="r"  mask="0x0fff0000"
                description=""/>
          <node id="UPPER"      address="0x0"  permission="r"  mask="0x0000ffff"
                description="5.3 and up this is B1"/>
          <node id="B5"         address="0x0"  permission="r"  mask="0x0000ff00"
                description="5.3 and up this is B1"/>
          <node id="B4"         address="0x0"  permission="r"  mask="0x000000ff"
                description="5.3 and up this is B2"/>
          <node id="LOWER"      address="0x0"  permission="r" 
                description="5.3 and up this is B1"/>
          <node id="B3"         address="0x0"  permission="r"  mask="0xff000000"
                description="5.3 and up this is B3"/>
          <node id="B2"         address="0x0"  permission="r"  mask="0x00ff0000"
                description="5.3 and up this is B4"/>
          <node id="B1"         address="0x0"  permission="r"  mask="0x0000ff00"
                description="5.3 and up this is B5"/>
          <node id="B0"         address="0x0"  permission="r"  mask="0x000000ff"
                description="5.3 and up this is B6"/>
        </node> <!--end mac_info-->

        <node id="IP_INFO"  address="0x0"
              description="only in firmware versions less than 5.3">
          <node id="B3"   mask="0xff000000" address="0x0"  permission="r"/>
          <node id="B2"   mask="0x00ff0000" address="0x0"  permission="r"/>
          <node id="B1"   mask="0x0000ff00" address="0x0"  permission="r"/>
          <node id="B0"   mask="0x000000ff" address="0x0"  permission="r"/>
        </node> <!--end ip_info-->

        <node id="HW_ID"  address="0x0"
              description="only in firmware versions 5.3 and up">
          <node id="B1"   address="0x0"  permission="r"  mask="0x0000ff00" />
          <node id="B2"   address="0x0"  permission="r"  mask="0x000000ff" />
          <node id="B3"   address="0x0"  permission="r"  mask="0xff000000" />
          <node id="B4"   address="0x0"  permission="r"  mask="0x00ff0000" />
          <node id="B5"   address="0x0"  permission="r"  mask="0x0000ff00" />
          <node id="B6"   address="0x0"  permission="r"  mask="0x000000ff" />
        </node>
        <!--end ip_info-->
      </node> <!--end GLIB system registers -->

      <node id="SRAM1"  address="0x0"   permission="r"
            description="SRAM1 memory space "/>

      <node id="SRAM2"  address="0x0"   permission="r"
            description="SRAM2 memory space"/>

      <node id="ICAP"  address="0x0"  mode="non-incremental"  permission="r"
            description="ICAP memory space (seems to not work at the moment)"/>

      <node id="FLASH"  address="0x0"  description="FLASH memory banks">
        <node id="BANK_15" description="512Kword">
          <node id="BLOCK_130"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_129"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_128"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_127"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_126"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_125"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_124"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_123"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_15-->

        <node id="BANK_14" description="512Kword">
          <node id="BLOCK_122"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_121"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_120"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_119"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_118"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_117"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_116"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_115"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_14-->

        <node id="BANK_13" description="512Kword">
          <node id="BLOCK_114"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_113"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_112"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_111"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_110"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_109"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_108"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_107"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_13-->

        <node id="BANK_12" description="512Kword">
          <node id="BLOCK_106"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_105"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_104"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_103"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_102"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_101"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_100"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_99"   address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_12-->

        <node id="BANK_11" description="512Kword">
          <node id="BLOCK_98"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_97"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_96"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_95"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_94"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_93"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_92"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_91"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_11-->

        <node id="BANK_10" description="512Kword">
          <node id="BLOCK_90"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_89"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_88"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_87"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_86"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_85"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_84"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_83"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_10-->

        <node id="BANK_9" description="512Kword">
          <node id="BLOCK_82"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_81"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_80"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_79"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_78"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_77"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_76"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_75"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_9-->

        <node id="BANK_8" description="512Kword">
          <node id="BLOCK_74"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_73"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_72"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_71"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_70"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_69"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_68"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_67"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_8-->

        <node id="BANK_7" description="512Kword">
          <node id="BLOCK_66"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_65"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_64"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_63"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_62"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_61"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_60"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_59"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_7-->

        <node id="BANK_6" description="512Kword">
          <node id="BLOCK_58"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_57"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_56"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_55"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_54"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_53"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_52"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_51"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_6-->

        <node id="BANK_5" description="512Kword">
          <node id="BLOCK_50"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_49"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_48"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_47"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_46"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_45"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_44"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_43"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_5-->

        <node id="BANK_4" description="512Kword">
          <node id="BLOCK_42"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_41"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_40"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_39"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_38"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_37"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_36"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_35"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_4-->

        <node id="BANK_3" description="512Kword">
          <node id="BLOCK_34"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_33"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_32"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_31"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_30"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_29"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_28"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_27"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_3-->

        <node id="BANK_2" description="512Kword">
          <node id="BLOCK_26"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_25"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_24"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_23"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_22"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_21"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_20"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_19"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_2-->

        <node id="BANK_1" description="512Kword">
          <node id="BLOCK_18"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_17"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_16"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_15"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_14"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_13"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_12"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_11"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_1-->

        <node id="PARAM_BANK" description="512Kword">
          <node id="BLOCK_10"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_9"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_8"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_7"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_6"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_5"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_4"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_3"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_2"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_1"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_0"   address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end PARAM_BANK-->
      </node>

      <node id="BOARD_ID" address="0x0" permission="r"
            description="GLIB Board ID code"
            fw_signal="legacy_board_id"/>
      <node id="SYSTEM_ID" address="0x1" permission="r"
            description="GLIB System ID code"
            fw_signal="legacy_sys_id"/>
      <node id="FIRMWARE_VERSION" address="0x2" permission="r"
            description="GLIB firmware version + firmware date"
            fw_signal="legacy_fw_version"/>
    </node> <!-- end of GLIB_SYSTEM -->

  </node>
</node>
